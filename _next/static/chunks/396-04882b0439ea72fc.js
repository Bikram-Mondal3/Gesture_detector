"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [396], {
        8311: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("ArrowLeft", [
                ["path", {
                    d: "m12 19-7-7 7-7",
                    key: "1l729n"
                }],
                ["path", {
                    d: "M19 12H5",
                    key: "x3x0zl"
                }]
            ])
        },
        4637: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("ArrowRight", [
                ["path", {
                    d: "M5 12h14",
                    key: "1ays0h"
                }],
                ["path", {
                    d: "m12 5 7 7-7 7",
                    key: "xquz4c"
                }]
            ])
        },
        5928: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("Check", [
                ["path", {
                    d: "M20 6 9 17l-5-5",
                    key: "1gmf2c"
                }]
            ])
        },
        4197: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("Play", [
                ["polygon", {
                    points: "6 3 20 12 6 21 6 3",
                    key: "1oa8hb"
                }]
            ])
        },
        5291: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("Star", [
                ["polygon", {
                    points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
                    key: "8f66p6"
                }]
            ])
        },
        7879: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            /**
             * @license lucide-react v0.417.0 - ISC
             *
             * This source code is licensed under the ISC license.
             * See the LICENSE file in the root directory of this source tree.
             */
            let n = (0, i(2012).Z)("X", [
                ["path", {
                    d: "M18 6 6 18",
                    key: "1bl5f8"
                }],
                ["path", {
                    d: "m6 6 12 12",
                    key: "d8bk6v"
                }]
            ])
        },
        8585: function(t, e, i) {
            i.d(e, {
                default: function() {
                    return r.a
                }
            });
            var n = i(4595),
                r = i.n(n)
        },
        4595: function(t, e, i) {
            Object.defineProperty(e, "__esModule", {
                    value: !0
                }),
                function(t, e) {
                    for (var i in e) Object.defineProperty(t, i, {
                        enumerable: !0,
                        get: e[i]
                    })
                }(e, {
                    default: function() {
                        return l
                    },
                    getImageProps: function() {
                        return a
                    }
                });
            let n = i(3192),
                r = i(2789),
                s = i(2559),
                o = n._(i(2591));

            function a(t) {
                let {
                    props: e
                } = (0, r.getImgProps)(t, {
                    defaultLoader: o.default,
                    imgConf: {
                        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
                        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
                        path: "/_next/image",
                        loader: "default",
                        dangerouslyAllowSVG: !1,
                        unoptimized: !1
                    }
                });
                for (let [t, i] of Object.entries(e)) void 0 === i && delete e[t];
                return {
                    props: e
                }
            }
            let l = s.Image
        },
        9501: function(t, e, i) {
            i.d(e, {
                VY: function() {
                    return to
                },
                h4: function() {
                    return tr
                },
                ck: function() {
                    return tn
                },
                fC: function() {
                    return ti
                },
                xz: function() {
                    return ts
                }
            });
            var n = i(6265),
                r = i(8944),
                s = i(4004),
                o = i(3250),
                a = i(369),
                l = i(7824),
                u = i(6248),
                h = i(8283),
                c = i(7258),
                d = i(9264),
                p = i(7949),
                f = "Collapsible",
                [m, v] = (0, r.b)(f),
                [g, y] = m(f),
                x = n.forwardRef((t, e) => {
                    let {
                        __scopeCollapsible: i,
                        open: r,
                        defaultOpen: s,
                        disabled: o,
                        onOpenChange: a,
                        ...h
                    } = t, [c = !1, f] = (0, l.T)({
                        prop: r,
                        defaultProp: s,
                        onChange: a
                    });
                    return (0, p.jsx)(g, {
                        scope: i,
                        disabled: o,
                        contentId: (0, d.M)(),
                        open: c,
                        onOpenToggle: n.useCallback(() => f(t => !t), [f]),
                        children: (0, p.jsx)(u.WV.div, {
                            "data-state": A(c),
                            "data-disabled": o ? "" : void 0,
                            ...h,
                            ref: e
                        })
                    })
                });
            x.displayName = f;
            var b = "CollapsibleTrigger",
                w = n.forwardRef((t, e) => {
                    let {
                        __scopeCollapsible: i,
                        ...n
                    } = t, r = y(b, i);
                    return (0, p.jsx)(u.WV.button, {
                        type: "button",
                        "aria-controls": r.contentId,
                        "aria-expanded": r.open || !1,
                        "data-state": A(r.open),
                        "data-disabled": r.disabled ? "" : void 0,
                        disabled: r.disabled,
                        ...n,
                        ref: e,
                        onClick: (0, a.M)(t.onClick, r.onOpenToggle)
                    })
                });
            w.displayName = b;
            var P = "CollapsibleContent",
                S = n.forwardRef((t, e) => {
                    let {
                        forceMount: i,
                        ...n
                    } = t, r = y(P, t.__scopeCollapsible);
                    return (0, p.jsx)(c.z, {
                        present: i || r.open,
                        children: t => {
                            let {
                                present: i
                            } = t;
                            return (0, p.jsx)(T, { ...n,
                                ref: e,
                                present: i
                            })
                        }
                    })
                });
            S.displayName = P;
            var T = n.forwardRef((t, e) => {
                let {
                    __scopeCollapsible: i,
                    present: r,
                    children: s,
                    ...a
                } = t, l = y(P, i), [c, d] = n.useState(r), f = n.useRef(null), m = (0, o.e)(e, f), v = n.useRef(0), g = v.current, x = n.useRef(0), b = x.current, w = l.open || c, S = n.useRef(w), T = n.useRef();
                return n.useEffect(() => {
                    let t = requestAnimationFrame(() => S.current = !1);
                    return () => cancelAnimationFrame(t)
                }, []), (0, h.b)(() => {
                    let t = f.current;
                    if (t) {
                        T.current = T.current || {
                            transitionDuration: t.style.transitionDuration,
                            animationName: t.style.animationName
                        }, t.style.transitionDuration = "0s", t.style.animationName = "none";
                        let e = t.getBoundingClientRect();
                        v.current = e.height, x.current = e.width, S.current || (t.style.transitionDuration = T.current.transitionDuration, t.style.animationName = T.current.animationName), d(r)
                    }
                }, [l.open, r]), (0, p.jsx)(u.WV.div, {
                    "data-state": A(l.open),
                    "data-disabled": l.disabled ? "" : void 0,
                    id: l.contentId,
                    hidden: !w,
                    ...a,
                    ref: m,
                    style: {
                        "--radix-collapsible-content-height": g ? "".concat(g, "px") : void 0,
                        "--radix-collapsible-content-width": b ? "".concat(b, "px") : void 0,
                        ...t.style
                    },
                    children: w && s
                })
            });

            function A(t) {
                return t ? "open" : "closed"
            }
            var E = i(2304),
                C = "Accordion",
                V = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"],
                [k, M, R] = (0, s.B)(C),
                [D, j] = (0, r.b)(C, [R, v]),
                L = v(),
                F = n.forwardRef((t, e) => {
                    let {
                        type: i,
                        ...n
                    } = t;
                    return (0, p.jsx)(k.Provider, {
                        scope: t.__scopeAccordion,
                        children: "multiple" === i ? (0, p.jsx)($, { ...n,
                            ref: e
                        }) : (0, p.jsx)(N, { ...n,
                            ref: e
                        })
                    })
                });
            F.displayName = C;
            var [O, B] = D(C), [I, U] = D(C, {
                collapsible: !1
            }), N = n.forwardRef((t, e) => {
                let {
                    value: i,
                    defaultValue: r,
                    onValueChange: s = () => {},
                    collapsible: o = !1,
                    ...a
                } = t, [u, h] = (0, l.T)({
                    prop: i,
                    defaultProp: r,
                    onChange: s
                });
                return (0, p.jsx)(O, {
                    scope: t.__scopeAccordion,
                    value: u ? [u] : [],
                    onItemOpen: h,
                    onItemClose: n.useCallback(() => o && h(""), [o, h]),
                    children: (0, p.jsx)(I, {
                        scope: t.__scopeAccordion,
                        collapsible: o,
                        children: (0, p.jsx)(H, { ...a,
                            ref: e
                        })
                    })
                })
            }), $ = n.forwardRef((t, e) => {
                let {
                    value: i,
                    defaultValue: r,
                    onValueChange: s = () => {},
                    ...o
                } = t, [a = [], u] = (0, l.T)({
                    prop: i,
                    defaultProp: r,
                    onChange: s
                }), h = n.useCallback(t => u(function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return [...e, t]
                }), [u]), c = n.useCallback(t => u(function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return e.filter(e => e !== t)
                }), [u]);
                return (0, p.jsx)(O, {
                    scope: t.__scopeAccordion,
                    value: a,
                    onItemOpen: h,
                    onItemClose: c,
                    children: (0, p.jsx)(I, {
                        scope: t.__scopeAccordion,
                        collapsible: !0,
                        children: (0, p.jsx)(H, { ...o,
                            ref: e
                        })
                    })
                })
            }), [W, z] = D(C), H = n.forwardRef((t, e) => {
                let {
                    __scopeAccordion: i,
                    disabled: r,
                    dir: s,
                    orientation: l = "vertical",
                    ...h
                } = t, c = n.useRef(null), d = (0, o.e)(c, e), f = M(i), m = "ltr" === (0, E.gm)(s), v = (0, a.M)(t.onKeyDown, t => {
                    var e;
                    if (!V.includes(t.key)) return;
                    let i = t.target,
                        n = f().filter(t => {
                            var e;
                            return !(null === (e = t.ref.current) || void 0 === e ? void 0 : e.disabled)
                        }),
                        r = n.findIndex(t => t.ref.current === i),
                        s = n.length;
                    if (-1 === r) return;
                    t.preventDefault();
                    let o = r,
                        a = s - 1,
                        u = () => {
                            (o = r + 1) > a && (o = 0)
                        },
                        h = () => {
                            (o = r - 1) < 0 && (o = a)
                        };
                    switch (t.key) {
                        case "Home":
                            o = 0;
                            break;
                        case "End":
                            o = a;
                            break;
                        case "ArrowRight":
                            "horizontal" === l && (m ? u() : h());
                            break;
                        case "ArrowDown":
                            "vertical" === l && u();
                            break;
                        case "ArrowLeft":
                            "horizontal" === l && (m ? h() : u());
                            break;
                        case "ArrowUp":
                            "vertical" === l && h()
                    }
                    null === (e = n[o % s].ref.current) || void 0 === e || e.focus()
                });
                return (0, p.jsx)(W, {
                    scope: i,
                    disabled: r,
                    direction: s,
                    orientation: l,
                    children: (0, p.jsx)(k.Slot, {
                        scope: i,
                        children: (0, p.jsx)(u.WV.div, { ...h,
                            "data-orientation": l,
                            ref: d,
                            onKeyDown: r ? void 0 : v
                        })
                    })
                })
            }), Z = "AccordionItem", [K, Y] = D(Z), _ = n.forwardRef((t, e) => {
                let {
                    __scopeAccordion: i,
                    value: n,
                    ...r
                } = t, s = z(Z, i), o = B(Z, i), a = L(i), l = (0, d.M)(), u = n && o.value.includes(n) || !1, h = s.disabled || t.disabled;
                return (0, p.jsx)(K, {
                    scope: i,
                    open: u,
                    disabled: h,
                    triggerId: l,
                    children: (0, p.jsx)(x, {
                        "data-orientation": s.orientation,
                        "data-state": te(u),
                        ...a,
                        ...r,
                        ref: e,
                        disabled: h,
                        open: u,
                        onOpenChange: t => {
                            t ? o.onItemOpen(n) : o.onItemClose(n)
                        }
                    })
                })
            });
            _.displayName = Z;
            var X = "AccordionHeader",
                q = n.forwardRef((t, e) => {
                    let {
                        __scopeAccordion: i,
                        ...n
                    } = t, r = z(C, i), s = Y(X, i);
                    return (0, p.jsx)(u.WV.h3, {
                        "data-orientation": r.orientation,
                        "data-state": te(s.open),
                        "data-disabled": s.disabled ? "" : void 0,
                        ...n,
                        ref: e
                    })
                });
            q.displayName = X;
            var G = "AccordionTrigger",
                J = n.forwardRef((t, e) => {
                    let {
                        __scopeAccordion: i,
                        ...n
                    } = t, r = z(C, i), s = Y(G, i), o = U(G, i), a = L(i);
                    return (0, p.jsx)(k.ItemSlot, {
                        scope: i,
                        children: (0, p.jsx)(w, {
                            "aria-disabled": s.open && !o.collapsible || void 0,
                            "data-orientation": r.orientation,
                            id: s.triggerId,
                            ...a,
                            ...n,
                            ref: e
                        })
                    })
                });
            J.displayName = G;
            var Q = "AccordionContent",
                tt = n.forwardRef((t, e) => {
                    let {
                        __scopeAccordion: i,
                        ...n
                    } = t, r = z(C, i), s = Y(Q, i), o = L(i);
                    return (0, p.jsx)(S, {
                        role: "region",
                        "aria-labelledby": s.triggerId,
                        "data-orientation": r.orientation,
                        ...o,
                        ...n,
                        ref: e,
                        style: {
                            "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
                            "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
                            ...t.style
                        }
                    })
                });

            function te(t) {
                return t ? "open" : "closed"
            }
            tt.displayName = Q;
            var ti = F,
                tn = _,
                tr = q,
                ts = J,
                to = tt
        },
        1273: function(t, e, i) {
            i.d(e, {
                f: function() {
                    return a
                }
            });
            var n = i(6265),
                r = i(6248),
                s = i(7949),
                o = n.forwardRef((t, e) => (0, s.jsx)(r.WV.label, { ...t,
                    ref: e,
                    onMouseDown: e => {
                        var i;
                        e.target.closest("button, input, select, textarea") || (null === (i = t.onMouseDown) || void 0 === i || i.call(t, e), !e.defaultPrevented && e.detail > 1 && e.preventDefault())
                    }
                }));
            o.displayName = "Label";
            var a = o
        },
        3640: function(t, e, i) {
            i.d(e, {
                fC: function() {
                    return P
                },
                bU: function() {
                    return S
                }
            });
            var n = i(6265),
                r = i(369),
                s = i(3250),
                o = i(8944),
                a = i(7824),
                l = i(2352),
                u = i(8283),
                h = i(6248),
                c = i(7949),
                d = "Switch",
                [p, f] = (0, o.b)(d),
                [m, v] = p(d),
                g = n.forwardRef((t, e) => {
                    let {
                        __scopeSwitch: i,
                        name: o,
                        checked: l,
                        defaultChecked: u,
                        required: d,
                        disabled: p,
                        value: f = "on",
                        onCheckedChange: v,
                        ...g
                    } = t, [y, x] = n.useState(null), P = (0, s.e)(e, t => x(t)), S = n.useRef(!1), T = !y || !!y.closest("form"), [A = !1, E] = (0, a.T)({
                        prop: l,
                        defaultProp: u,
                        onChange: v
                    });
                    return (0, c.jsxs)(m, {
                        scope: i,
                        checked: A,
                        disabled: p,
                        children: [(0, c.jsx)(h.WV.button, {
                            type: "button",
                            role: "switch",
                            "aria-checked": A,
                            "aria-required": d,
                            "data-state": w(A),
                            "data-disabled": p ? "" : void 0,
                            disabled: p,
                            value: f,
                            ...g,
                            ref: P,
                            onClick: (0, r.M)(t.onClick, t => {
                                E(t => !t), T && (S.current = t.isPropagationStopped(), S.current || t.stopPropagation())
                            })
                        }), T && (0, c.jsx)(b, {
                            control: y,
                            bubbles: !S.current,
                            name: o,
                            value: f,
                            checked: A,
                            required: d,
                            disabled: p,
                            style: {
                                transform: "translateX(-100%)"
                            }
                        })]
                    })
                });
            g.displayName = d;
            var y = "SwitchThumb",
                x = n.forwardRef((t, e) => {
                    let {
                        __scopeSwitch: i,
                        ...n
                    } = t, r = v(y, i);
                    return (0, c.jsx)(h.WV.span, {
                        "data-state": w(r.checked),
                        "data-disabled": r.disabled ? "" : void 0,
                        ...n,
                        ref: e
                    })
                });
            x.displayName = y;
            var b = t => {
                let {
                    control: e,
                    checked: i,
                    bubbles: r = !0,
                    ...s
                } = t, o = n.useRef(null), a = (0, l.D)(i), h = function(t) {
                    let [e, i] = n.useState(void 0);
                    return (0, u.b)(() => {
                        if (t) {
                            i({
                                width: t.offsetWidth,
                                height: t.offsetHeight
                            });
                            let e = new ResizeObserver(e => {
                                let n, r;
                                if (!Array.isArray(e) || !e.length) return;
                                let s = e[0];
                                if ("borderBoxSize" in s) {
                                    let t = s.borderBoxSize,
                                        e = Array.isArray(t) ? t[0] : t;
                                    n = e.inlineSize, r = e.blockSize
                                } else n = t.offsetWidth, r = t.offsetHeight;
                                i({
                                    width: n,
                                    height: r
                                })
                            });
                            return e.observe(t, {
                                box: "border-box"
                            }), () => e.unobserve(t)
                        }
                        i(void 0)
                    }, [t]), e
                }(e);
                return n.useEffect(() => {
                    let t = o.current,
                        e = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "checked").set;
                    if (a !== i && e) {
                        let n = new Event("click", {
                            bubbles: r
                        });
                        e.call(t, i), t.dispatchEvent(n)
                    }
                }, [a, i, r]), (0, c.jsx)("input", {
                    type: "checkbox",
                    "aria-hidden": !0,
                    defaultChecked: i,
                    ...s,
                    tabIndex: -1,
                    ref: o,
                    style: { ...t.style,
                        ...h,
                        position: "absolute",
                        pointerEvents: "none",
                        opacity: 0,
                        margin: 0
                    }
                })
            };

            function w(t) {
                return t ? "checked" : "unchecked"
            }
            var P = g,
                S = x
        },
        5296: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return A
                }
            });
            var n = i(6265);

            function r(t) {
                return "[object Object]" === Object.prototype.toString.call(t) || Array.isArray(t)
            }

            function s(t, e) {
                let i = Object.keys(t),
                    n = Object.keys(e);
                return i.length === n.length && JSON.stringify(Object.keys(t.breakpoints || {})) === JSON.stringify(Object.keys(e.breakpoints || {})) && i.every(i => {
                    let n = t[i],
                        o = e[i];
                    return "function" == typeof n ? `${n}` == `${o}` : r(n) && r(o) ? s(n, o) : n === o
                })
            }

            function o(t) {
                return t.concat().sort((t, e) => t.name > e.name ? 1 : -1).map(t => t.options)
            }

            function a(t) {
                return "number" == typeof t
            }

            function l(t) {
                return "string" == typeof t
            }

            function u(t) {
                return "boolean" == typeof t
            }

            function h(t) {
                return "[object Object]" === Object.prototype.toString.call(t)
            }

            function c(t) {
                return Math.abs(t)
            }

            function d(t) {
                return Math.sign(t)
            }

            function p(t) {
                return g(t).map(Number)
            }

            function f(t) {
                return t[m(t)]
            }

            function m(t) {
                return Math.max(0, t.length - 1)
            }

            function v(t, e = 0) {
                return Array.from(Array(t), (t, i) => e + i)
            }

            function g(t) {
                return Object.keys(t)
            }

            function y(t, e) {
                return void 0 !== e.MouseEvent && t instanceof e.MouseEvent
            }

            function x() {
                let t = [],
                    e = {
                        add: function(i, n, r, s = {
                            passive: !0
                        }) {
                            let o;
                            return "addEventListener" in i ? (i.addEventListener(n, r, s), o = () => i.removeEventListener(n, r, s)) : (i.addListener(r), o = () => i.removeListener(r)), t.push(o), e
                        },
                        clear: function() {
                            t = t.filter(t => t())
                        }
                    };
                return e
            }

            function b(t = 0, e = 0) {
                let i = c(t - e);

                function n(i) {
                    return i < t || i > e
                }
                return {
                    length: i,
                    max: e,
                    min: t,
                    constrain: function(i) {
                        return n(i) ? i < t ? t : e : i
                    },
                    reachedAny: n,
                    reachedMax: function(t) {
                        return t > e
                    },
                    reachedMin: function(e) {
                        return e < t
                    },
                    removeOffset: function(t) {
                        return i ? t - i * Math.ceil((t - e) / i) : t
                    }
                }
            }

            function w(t) {
                let e = t;

                function i(t) {
                    return a(t) ? t : t.get()
                }
                return {
                    get: function() {
                        return e
                    },
                    set: function(t) {
                        e = i(t)
                    },
                    add: function(t) {
                        e += i(t)
                    },
                    subtract: function(t) {
                        e -= i(t)
                    }
                }
            }

            function P(t, e) {
                let i = "x" === t.scroll ? function(t) {
                        return `translate3d(${t}px,0px,0px)`
                    } : function(t) {
                        return `translate3d(0px,${t}px,0px)`
                    },
                    n = e.style,
                    r = !1;
                return {
                    clear: function() {
                        r || (n.transform = "", e.getAttribute("style") || e.removeAttribute("style"))
                    },
                    to: function(e) {
                        r || (n.transform = i(t.direction(e)))
                    },
                    toggleActive: function(t) {
                        r = !t
                    }
                }
            }
            let S = {
                align: "center",
                axis: "x",
                container: null,
                slides: null,
                containScroll: "trimSnaps",
                direction: "ltr",
                slidesToScroll: 1,
                inViewThreshold: 0,
                breakpoints: {},
                dragFree: !1,
                dragThreshold: 10,
                loop: !1,
                skipSnaps: !1,
                duration: 25,
                startIndex: 0,
                active: !0,
                watchDrag: !0,
                watchResize: !0,
                watchSlides: !0
            };

            function T(t, e, i) {
                let n, r, s, o, A;
                let E = t.ownerDocument,
                    C = E.defaultView,
                    V = function(t) {
                        function e(t, e) {
                            return function t(e, i) {
                                return [e, i].reduce((e, i) => (g(i).forEach(n => {
                                    let r = e[n],
                                        s = i[n],
                                        o = h(r) && h(s);
                                    e[n] = o ? t(r, s) : s
                                }), e), {})
                            }(t, e || {})
                        }
                        return {
                            mergeOptions: e,
                            optionsAtMedia: function(i) {
                                let n = i.breakpoints || {},
                                    r = g(n).filter(e => t.matchMedia(e).matches).map(t => n[t]).reduce((t, i) => e(t, i), {});
                                return e(i, r)
                            },
                            optionsMediaQueries: function(e) {
                                return e.map(t => g(t.breakpoints || {})).reduce((t, e) => t.concat(e), []).map(t.matchMedia)
                            }
                        }
                    }(C),
                    k = (A = [], {
                        init: function(t, e) {
                            return (A = e.filter(({
                                options: t
                            }) => !1 !== V.optionsAtMedia(t).active)).forEach(e => e.init(t, V)), e.reduce((t, e) => Object.assign(t, {
                                [e.name]: e
                            }), {})
                        },
                        destroy: function() {
                            A = A.filter(t => t.destroy())
                        }
                    }),
                    M = x(),
                    R = function() {
                        let t, e = {},
                            i = {
                                init: function(e) {
                                    t = e
                                },
                                emit: function(n) {
                                    return (e[n] || []).forEach(e => e(t, n)), i
                                },
                                off: function(t, n) {
                                    return e[t] = (e[t] || []).filter(t => t !== n), i
                                },
                                on: function(t, n) {
                                    return e[t] = (e[t] || []).concat([n]), i
                                },
                                clear: function() {
                                    e = {}
                                }
                            };
                        return i
                    }(),
                    {
                        mergeOptions: D,
                        optionsAtMedia: j,
                        optionsMediaQueries: L
                    } = V,
                    {
                        on: F,
                        off: O,
                        emit: B
                    } = R,
                    I = !1,
                    U = D(S, T.globalOptions),
                    N = D(U),
                    $ = [];

                function W(e, i) {
                    !I && (N = j(U = D(U, e)), $ = i || $, function() {
                        let {
                            container: e,
                            slides: i
                        } = N;
                        s = (l(e) ? t.querySelector(e) : e) || t.children[0];
                        let n = l(i) ? s.querySelectorAll(i) : i;
                        o = [].slice.call(n || s.children)
                    }(), n = function e(i) {
                        let n = function(t, e, i, n, r, s, o) {
                            let h, S;
                            let {
                                align: T,
                                axis: A,
                                direction: E,
                                startIndex: C,
                                loop: V,
                                duration: k,
                                dragFree: M,
                                dragThreshold: R,
                                inViewThreshold: D,
                                slidesToScroll: j,
                                skipSnaps: L,
                                containScroll: F,
                                watchResize: O,
                                watchSlides: B,
                                watchDrag: I
                            } = s, U = {
                                measure: function(t) {
                                    let {
                                        offsetTop: e,
                                        offsetLeft: i,
                                        offsetWidth: n,
                                        offsetHeight: r
                                    } = t;
                                    return {
                                        top: e,
                                        right: i + n,
                                        bottom: e + r,
                                        left: i,
                                        width: n,
                                        height: r
                                    }
                                }
                            }, N = U.measure(e), $ = i.map(U.measure), W = function(t, e) {
                                let i = "rtl" === e,
                                    n = "y" === t,
                                    r = !n && i ? -1 : 1;
                                return {
                                    scroll: n ? "y" : "x",
                                    cross: n ? "x" : "y",
                                    startEdge: n ? "top" : i ? "right" : "left",
                                    endEdge: n ? "bottom" : i ? "left" : "right",
                                    measureSize: function(t) {
                                        let {
                                            height: e,
                                            width: i
                                        } = t;
                                        return n ? e : i
                                    },
                                    direction: function(t) {
                                        return t * r
                                    }
                                }
                            }(A, E), z = W.measureSize(N), H = {
                                measure: function(t) {
                                    return t / 100 * z
                                }
                            }, Z = function(t, e) {
                                let i = {
                                    start: function() {
                                        return 0
                                    },
                                    center: function(t) {
                                        return (e - t) / 2
                                    },
                                    end: function(t) {
                                        return e - t
                                    }
                                };
                                return {
                                    measure: function(n, r) {
                                        return l(t) ? i[t](n) : t(e, n, r)
                                    }
                                }
                            }(T, z), K = !V && !!F, {
                                slideSizes: Y,
                                slideSizesWithGaps: _,
                                startGap: X,
                                endGap: q
                            } = function(t, e, i, n, r, s) {
                                let {
                                    measureSize: o,
                                    startEdge: a,
                                    endEdge: l
                                } = t, u = i[0] && r, h = function() {
                                    if (!u) return 0;
                                    let t = i[0];
                                    return c(e[a] - t[a])
                                }(), d = u ? parseFloat(s.getComputedStyle(f(n)).getPropertyValue(`margin-${l}`)) : 0, p = i.map(o), v = i.map((t, e, i) => {
                                    let n = e === m(i);
                                    return e ? n ? p[e] + d : i[e + 1][a] - t[a] : p[e] + h
                                }).map(c);
                                return {
                                    slideSizes: p,
                                    slideSizesWithGaps: v,
                                    startGap: h,
                                    endGap: d
                                }
                            }(W, N, $, i, V || !!F, r), G = function(t, e, i, n, r, s, o, l, u) {
                                let {
                                    startEdge: h,
                                    endEdge: d,
                                    direction: v
                                } = t, g = a(i);
                                return {
                                    groupSlides: function(t) {
                                        return g ? p(t).filter(t => t % i == 0).map(e => t.slice(e, e + i)) : t.length ? p(t).reduce((i, a, u) => {
                                            let p = f(i) || 0,
                                                g = a === m(t),
                                                y = r[h] - s[p][h],
                                                x = r[h] - s[a][d],
                                                b = n || 0 !== p ? 0 : v(o),
                                                w = c(x - (!n && g ? v(l) : 0) - (y + b));
                                            return u && w > e + 2 && i.push(a), g && i.push(t.length), i
                                        }, []).map((e, i, n) => {
                                            let r = Math.max(n[i - 1] || 0);
                                            return t.slice(r, e)
                                        }) : []
                                    }
                                }
                            }(W, z, j, V, N, $, X, q, 0), {
                                snaps: J,
                                snapsAligned: Q
                            } = function(t, e, i, n, r) {
                                let {
                                    startEdge: s,
                                    endEdge: o
                                } = t, {
                                    groupSlides: a
                                } = r, l = a(n).map(t => f(t)[o] - t[0][s]).map(c).map(e.measure), u = n.map(t => i[s] - t[s]).map(t => -c(t)), h = a(u).map(t => t[0]).map((t, e) => t + l[e]);
                                return {
                                    snaps: u,
                                    snapsAligned: h
                                }
                            }(W, Z, N, $, G), tt = -f(J) + f(_), {
                                snapsContained: te,
                                scrollContainLimit: ti
                            } = function(t, e, i, n, r) {
                                let s = b(-e + t, 0),
                                    o = i.map((t, e) => {
                                        let {
                                            min: n,
                                            max: r
                                        } = s, o = s.constrain(t), a = e === m(i);
                                        return e ? a || 1 > c(n - o) ? n : 1 > c(r - o) ? r : o : r
                                    }).map(t => parseFloat(t.toFixed(3))),
                                    a = function() {
                                        let t = o[0],
                                            e = f(o);
                                        return b(o.lastIndexOf(t), o.indexOf(e) + 1)
                                    }();
                                return {
                                    snapsContained: function() {
                                        if (e <= t + 2) return [s.max];
                                        if ("keepSnaps" === n) return o;
                                        let {
                                            min: i,
                                            max: r
                                        } = a;
                                        return o.slice(i, r)
                                    }(),
                                    scrollContainLimit: a
                                }
                            }(z, tt, Q, F, 0), tn = K ? te : Q, {
                                limit: tr
                            } = function(t, e, i) {
                                let n = e[0];
                                return {
                                    limit: b(i ? n - t : f(e), n)
                                }
                            }(tt, tn, V), ts = function t(e, i, n) {
                                let {
                                    constrain: r
                                } = b(0, e), s = e + 1, o = a(i);

                                function a(t) {
                                    return n ? c((s + t) % s) : r(t)
                                }

                                function l() {
                                    return t(e, o, n)
                                }
                                let u = {
                                    get: function() {
                                        return o
                                    },
                                    set: function(t) {
                                        return o = a(t), u
                                    },
                                    add: function(t) {
                                        return l().set(o + t)
                                    },
                                    clone: l
                                };
                                return u
                            }(m(tn), C, V), to = ts.clone(), ta = p(i), tl = ({
                                dragHandler: t,
                                scrollBody: e,
                                scrollBounds: i,
                                options: {
                                    loop: n
                                }
                            }, r) => {
                                n || i.constrain(t.pointerDown()), e.seek(r)
                            }, tu = ({
                                scrollBody: t,
                                translate: e,
                                location: i,
                                offsetLocation: n,
                                scrollLooper: r,
                                slideLooper: s,
                                dragHandler: o,
                                animation: a,
                                eventHandler: l,
                                scrollBounds: u,
                                options: {
                                    loop: h
                                }
                            }, c) => {
                                let d = t.settled(),
                                    p = !u.shouldConstrain(),
                                    f = h ? d : d && p;
                                f && !o.pointerDown() && (a.stop(), l.emit("settle")), f || l.emit("scroll");
                                let m = i.get() * c + tp.get() * (1 - c);
                                n.set(m), h && (r.loop(t.direction()), s.loop()), e.to(n.get())
                            }, th = function(t, e, i, n) {
                                let r = x(),
                                    s = 1e3 / 60,
                                    o = null,
                                    a = 0,
                                    l = 0;

                                function u(t) {
                                    if (!l) return;
                                    o || (o = t);
                                    let r = t - o;
                                    for (o = t, a += r; a >= s;) i(s), a -= s;
                                    n(a / s), l && e.requestAnimationFrame(u)
                                }

                                function h() {
                                    e.cancelAnimationFrame(l), o = null, a = 0, l = 0
                                }
                                return {
                                    init: function() {
                                        r.add(t, "visibilitychange", () => {
                                            t.hidden && (o = null, a = 0)
                                        })
                                    },
                                    destroy: function() {
                                        h(), r.clear()
                                    },
                                    start: function() {
                                        l || (l = e.requestAnimationFrame(u))
                                    },
                                    stop: h,
                                    update: () => i(s),
                                    render: n
                                }
                            }(n, r, t => tl(tT, t), t => tu(tT, t)), tc = tn[ts.get()], td = w(tc), tp = w(tc), tf = w(tc), tm = w(tc), tv = function(t, e, i, n, r, s) {
                                let o = 0,
                                    a = 0,
                                    l = r,
                                    u = .68,
                                    h = t.get(),
                                    p = 0;

                                function f(t) {
                                    return l = t, v
                                }

                                function m(t) {
                                    return u = t, v
                                }
                                let v = {
                                    direction: function() {
                                        return a
                                    },
                                    duration: function() {
                                        return l
                                    },
                                    velocity: function() {
                                        return o
                                    },
                                    seek: function(e) {
                                        let r = e / 1e3,
                                            s = l * r,
                                            c = n.get() - t.get(),
                                            f = 0;
                                        return l ? (i.set(t), o += c / s, o *= u, h += o, t.add(o * r), f = h - p) : (o = 0, i.set(n), t.set(n), f = c), a = d(f), p = h, v
                                    },
                                    settled: function() {
                                        return .001 > c(n.get() - e.get())
                                    },
                                    useBaseFriction: function() {
                                        return m(.68)
                                    },
                                    useBaseDuration: function() {
                                        return f(r)
                                    },
                                    useFriction: m,
                                    useDuration: f
                                };
                                return v
                            }(td, tf, tp, tm, k, 0), tg = function(t, e, i, n, r) {
                                let {
                                    reachedAny: s,
                                    removeOffset: o,
                                    constrain: a
                                } = n;

                                function l(t) {
                                    return t.concat().sort((t, e) => c(t) - c(e))[0]
                                }

                                function u(e, n) {
                                    let r = [e, e + i, e - i];
                                    if (!t) return e;
                                    if (!n) return l(r);
                                    let s = r.filter(t => d(t) === n);
                                    return s.length ? l(s) : f(r) - i
                                }
                                return {
                                    byDistance: function(i, n) {
                                        let l = r.get() + i,
                                            {
                                                index: h,
                                                distance: d
                                            } = function(i) {
                                                let n = t ? o(i) : a(i),
                                                    {
                                                        index: r
                                                    } = e.map((t, e) => ({
                                                        diff: u(t - n, 0),
                                                        index: e
                                                    })).sort((t, e) => c(t.diff) - c(e.diff))[0];
                                                return {
                                                    index: r,
                                                    distance: n
                                                }
                                            }(l),
                                            p = !t && s(l);
                                        if (!n || p) return {
                                            index: h,
                                            distance: i
                                        };
                                        let f = i + u(e[h] - d, 0);
                                        return {
                                            index: h,
                                            distance: f
                                        }
                                    },
                                    byIndex: function(t, i) {
                                        let n = u(e[t] - r.get(), i);
                                        return {
                                            index: t,
                                            distance: n
                                        }
                                    },
                                    shortcut: u
                                }
                            }(V, tn, tt, tr, tm), ty = function(t, e, i, n, r, s, o) {
                                function a(r) {
                                    let a = r.distance,
                                        l = r.index !== e.get();
                                    s.add(a), a && (n.duration() ? t.start() : (t.update(), t.render(1), t.update())), l && (i.set(e.get()), e.set(r.index), o.emit("select"))
                                }
                                return {
                                    distance: function(t, e) {
                                        a(r.byDistance(t, e))
                                    },
                                    index: function(t, i) {
                                        let n = e.clone().set(t);
                                        a(r.byIndex(n.get(), i))
                                    }
                                }
                            }(th, ts, to, tv, tg, tm, o), tx = function(t) {
                                let {
                                    max: e,
                                    length: i
                                } = t;
                                return {
                                    get: function(t) {
                                        return i ? -((t - e) / i) : 0
                                    }
                                }
                            }(tr), tb = x(), tw = function(t, e, i, n) {
                                let r;
                                let s = {},
                                    o = null,
                                    a = null,
                                    l = !1;
                                return {
                                    init: function() {
                                        r = new IntersectionObserver(t => {
                                            l || (t.forEach(t => {
                                                s[e.indexOf(t.target)] = t
                                            }), o = null, a = null, i.emit("slidesInView"))
                                        }, {
                                            root: t.parentElement,
                                            threshold: n
                                        }), e.forEach(t => r.observe(t))
                                    },
                                    destroy: function() {
                                        r && r.disconnect(), l = !0
                                    },
                                    get: function(t = !0) {
                                        if (t && o) return o;
                                        if (!t && a) return a;
                                        let e = g(s).reduce((e, i) => {
                                            let n = parseInt(i),
                                                {
                                                    isIntersecting: r
                                                } = s[n];
                                            return (t && r || !t && !r) && e.push(n), e
                                        }, []);
                                        return t && (o = e), t || (a = e), e
                                    }
                                }
                            }(e, i, o, D), {
                                slideRegistry: tP
                            } = function(t, e, i, n, r, s) {
                                let {
                                    groupSlides: o
                                } = r, {
                                    min: a,
                                    max: l
                                } = n;
                                return {
                                    slideRegistry: function() {
                                        let n = o(s);
                                        return 1 === i.length ? [s] : t && "keepSnaps" !== e ? n.slice(a, l).map((t, e, i) => {
                                            let n = e === m(i);
                                            return e ? n ? v(m(s) - f(i)[0] + 1, f(i)[0]) : t : v(f(i[0]) + 1)
                                        }) : n
                                    }()
                                }
                            }(K, F, tn, ti, G, ta), tS = function(t, e, i, n, r, s, o) {
                                let l = 0;

                                function u(t) {
                                    "Tab" === t.code && (l = new Date().getTime())
                                }

                                function h(u) {
                                    s.add(u, "focus", () => {
                                        if (new Date().getTime() - l > 10) return;
                                        t.scrollLeft = 0;
                                        let s = e.indexOf(u),
                                            h = i.findIndex(t => t.includes(s));
                                        a(h) && (r.useDuration(0), n.index(h, 0), o.emit("slideFocus"))
                                    }, {
                                        passive: !0,
                                        capture: !0
                                    })
                                }
                                return {
                                    init: function() {
                                        s.add(document, "keydown", u, !1), e.forEach(h)
                                    }
                                }
                            }(t, i, tP, ty, tv, tb, o), tT = {
                                ownerDocument: n,
                                ownerWindow: r,
                                eventHandler: o,
                                containerRect: N,
                                slideRects: $,
                                animation: th,
                                axis: W,
                                dragHandler: function(t, e, i, n, r, s, o, a, l, h, p, f, m, v, g, w, P, S, T) {
                                    let {
                                        cross: A,
                                        direction: E
                                    } = t, C = ["INPUT", "SELECT", "TEXTAREA"], V = {
                                        passive: !1
                                    }, k = x(), M = x(), R = b(50, 225).constrain(v.measure(20)), D = {
                                        mouse: 300,
                                        touch: 400
                                    }, j = {
                                        mouse: 500,
                                        touch: 600
                                    }, L = g ? 43 : 25, F = !1, O = 0, B = 0, I = !1, U = !1, N = !1, $ = !1;

                                    function W(t) {
                                        if (!y(t, n) && t.touches.length >= 2) return z(t);
                                        let e = s.readPoint(t),
                                            i = s.readPoint(t, A),
                                            o = c(e - O),
                                            l = c(i - B);
                                        if (!U && !$ && (!t.cancelable || !(U = o > l))) return z(t);
                                        let u = s.pointerMove(t);
                                        o > w && (N = !0), h.useFriction(.3).useDuration(.75), a.start(), r.add(E(u)), t.preventDefault()
                                    }

                                    function z(t) {
                                        let e = p.byDistance(0, !1).index !== f.get(),
                                            i = s.pointerUp(t) * (g ? j : D)[$ ? "mouse" : "touch"],
                                            n = function(t, e) {
                                                let i = f.add(-1 * d(t)),
                                                    n = p.byDistance(t, !g).distance;
                                                return g || c(t) < R ? n : P && e ? .5 * n : p.byIndex(i.get(), 0).distance
                                            }(E(i), e),
                                            r = function(t, e) {
                                                var i, n;
                                                if (0 === t || 0 === e || c(t) <= c(e)) return 0;
                                                let r = (i = c(t), n = c(e), c(i - n));
                                                return c(r / t)
                                            }(i, n);
                                        U = !1, I = !1, M.clear(), h.useDuration(L - 10 * r).useFriction(.68 + r / 50), l.distance(n, !g), $ = !1, m.emit("pointerUp")
                                    }

                                    function H(t) {
                                        N && (t.stopPropagation(), t.preventDefault(), N = !1)
                                    }
                                    return {
                                        init: function(t) {
                                            T && k.add(e, "dragstart", t => t.preventDefault(), V).add(e, "touchmove", () => void 0, V).add(e, "touchend", () => void 0).add(e, "touchstart", a).add(e, "mousedown", a).add(e, "touchcancel", z).add(e, "contextmenu", z).add(e, "click", H, !0);

                                            function a(a) {
                                                (u(T) || T(t, a)) && function(t) {
                                                    let a = y(t, n);
                                                    $ = a, N = g && a && !t.buttons && F, F = c(r.get() - o.get()) >= 2, a && 0 !== t.button || function(t) {
                                                        let e = t.nodeName || "";
                                                        return C.includes(e)
                                                    }(t.target) || (I = !0, s.pointerDown(t), h.useFriction(0).useDuration(0), r.set(o), function() {
                                                        let t = $ ? i : e;
                                                        M.add(t, "touchmove", W, V).add(t, "touchend", z).add(t, "mousemove", W, V).add(t, "mouseup", z)
                                                    }(), O = s.readPoint(t), B = s.readPoint(t, A), m.emit("pointerDown"))
                                                }(a)
                                            }
                                        },
                                        destroy: function() {
                                            k.clear(), M.clear()
                                        },
                                        pointerDown: function() {
                                            return I
                                        }
                                    }
                                }(W, t, n, r, tm, function(t, e) {
                                    let i, n;

                                    function r(t) {
                                        return t.timeStamp
                                    }

                                    function s(i, n) {
                                        let r = n || t.scroll,
                                            s = `client${"x"===r?"X":"Y"}`;
                                        return (y(i, e) ? i : i.touches[0])[s]
                                    }
                                    return {
                                        pointerDown: function(t) {
                                            return i = t, n = t, s(t)
                                        },
                                        pointerMove: function(t) {
                                            let e = s(t) - s(n),
                                                o = r(t) - r(i) > 170;
                                            return n = t, o && (i = t), e
                                        },
                                        pointerUp: function(t) {
                                            if (!i || !n) return 0;
                                            let e = s(n) - s(i),
                                                o = r(t) - r(i),
                                                a = r(t) - r(n) > 170,
                                                l = e / o;
                                            return o && !a && c(l) > .1 ? l : 0
                                        },
                                        readPoint: s
                                    }
                                }(W, r), td, th, ty, tv, tg, ts, o, H, M, R, L, 0, I),
                                eventStore: tb,
                                percentOfView: H,
                                index: ts,
                                indexPrevious: to,
                                limit: tr,
                                location: td,
                                offsetLocation: tf,
                                previousLocation: tp,
                                options: s,
                                resizeHandler: function(t, e, i, n, r, s, o) {
                                    let a, l;
                                    let h = [t].concat(n),
                                        d = [],
                                        p = !1;

                                    function f(t) {
                                        return r.measureSize(o.measure(t))
                                    }
                                    return {
                                        init: function(r) {
                                            s && (l = f(t), d = n.map(f), a = new ResizeObserver(i => {
                                                (u(s) || s(r, i)) && function(i) {
                                                    for (let s of i) {
                                                        if (p) return;
                                                        let i = s.target === t,
                                                            o = n.indexOf(s.target),
                                                            a = i ? l : d[o];
                                                        if (c(f(i ? t : n[o]) - a) >= .5) {
                                                            r.reInit(), e.emit("resize");
                                                            break
                                                        }
                                                    }
                                                }(i)
                                            }), i.requestAnimationFrame(() => {
                                                h.forEach(t => a.observe(t))
                                            }))
                                        },
                                        destroy: function() {
                                            p = !0, a && a.disconnect()
                                        }
                                    }
                                }(e, o, r, i, W, O, U),
                                scrollBody: tv,
                                scrollBounds: function(t, e, i, n, r) {
                                    let s = r.measure(10),
                                        o = r.measure(50),
                                        a = b(.1, .99),
                                        l = !1;

                                    function u() {
                                        return !!(!l && t.reachedAny(i.get()) && t.reachedAny(e.get()))
                                    }
                                    return {
                                        shouldConstrain: u,
                                        constrain: function(r) {
                                            if (!u()) return;
                                            let l = t.reachedMin(e.get()) ? "min" : "max",
                                                h = c(t[l] - e.get()),
                                                d = i.get() - e.get(),
                                                p = a.constrain(h / o);
                                            i.subtract(d * p), !r && c(d) < s && (i.set(t.constrain(i.get())), n.useDuration(25).useBaseFriction())
                                        },
                                        toggleActive: function(t) {
                                            l = !t
                                        }
                                    }
                                }(tr, tf, tm, tv, H),
                                scrollLooper: function(t, e, i, n) {
                                    let {
                                        reachedMin: r,
                                        reachedMax: s
                                    } = b(e.min + .1, e.max + .1);
                                    return {
                                        loop: function(e) {
                                            if (!(1 === e ? s(i.get()) : -1 === e && r(i.get()))) return;
                                            let o = -1 * e * t;
                                            n.forEach(t => t.add(o))
                                        }
                                    }
                                }(tt, tr, tf, [td, tf, tp, tm]),
                                scrollProgress: tx,
                                scrollSnapList: tn.map(tx.get),
                                scrollSnaps: tn,
                                scrollTarget: tg,
                                scrollTo: ty,
                                slideLooper: function(t, e, i, n, r, s, o, a, l) {
                                    let u = p(r),
                                        h = f(d(p(r).reverse(), o[0]), i, !1).concat(f(d(u, e - o[0] - 1), -i, !0));

                                    function c(t, e) {
                                        return t.reduce((t, e) => t - r[e], e)
                                    }

                                    function d(t, e) {
                                        return t.reduce((t, i) => c(t, e) > 0 ? t.concat([i]) : t, [])
                                    }

                                    function f(r, o, u) {
                                        let h = s.map((t, i) => ({
                                            start: t - n[i] + .5 + o,
                                            end: t + e - .5 + o
                                        }));
                                        return r.map(e => {
                                            let n = u ? 0 : -i,
                                                r = u ? i : 0,
                                                s = h[e][u ? "end" : "start"];
                                            return {
                                                index: e,
                                                loopPoint: s,
                                                slideLocation: w(-1),
                                                translate: P(t, l[e]),
                                                target: () => a.get() > s ? n : r
                                            }
                                        })
                                    }
                                    return {
                                        canLoop: function() {
                                            return h.every(({
                                                index: t
                                            }) => .1 >= c(u.filter(e => e !== t), e))
                                        },
                                        clear: function() {
                                            h.forEach(t => t.translate.clear())
                                        },
                                        loop: function() {
                                            h.forEach(t => {
                                                let {
                                                    target: e,
                                                    translate: i,
                                                    slideLocation: n
                                                } = t, r = e();
                                                r !== n.get() && (i.to(r), n.set(r))
                                            })
                                        },
                                        loopPoints: h
                                    }
                                }(W, z, tt, Y, _, J, tn, tf, i),
                                slideFocus: tS,
                                slidesHandler: (S = !1, {
                                    init: function(t) {
                                        B && (h = new MutationObserver(e => {
                                            !S && (u(B) || B(t, e)) && function(e) {
                                                for (let i of e)
                                                    if ("childList" === i.type) {
                                                        t.reInit(), o.emit("slidesChanged");
                                                        break
                                                    }
                                            }(e)
                                        })).observe(e, {
                                            childList: !0
                                        })
                                    },
                                    destroy: function() {
                                        h && h.disconnect(), S = !0
                                    }
                                }),
                                slidesInView: tw,
                                slideIndexes: ta,
                                slideRegistry: tP,
                                slidesToScroll: G,
                                target: tm,
                                translate: P(W, e)
                            };
                            return tT
                        }(t, s, o, E, C, i, R);
                        return i.loop && !n.slideLooper.canLoop() ? e(Object.assign({}, i, {
                            loop: !1
                        })) : n
                    }(N), L([U, ...$.map(({
                        options: t
                    }) => t)]).forEach(t => M.add(t, "change", z)), N.active && (n.translate.to(n.location.get()), n.animation.init(), n.slidesInView.init(), n.slideFocus.init(), n.eventHandler.init(Y), n.resizeHandler.init(Y), n.slidesHandler.init(Y), n.options.loop && n.slideLooper.loop(), s.offsetParent && o.length && n.dragHandler.init(Y), r = k.init(Y, $)))
                }

                function z(t, e) {
                    let i = K();
                    H(), W(D({
                        startIndex: i
                    }, t), e), R.emit("reInit")
                }

                function H() {
                    n.dragHandler.destroy(), n.eventStore.clear(), n.translate.clear(), n.slideLooper.clear(), n.resizeHandler.destroy(), n.slidesHandler.destroy(), n.slidesInView.destroy(), n.animation.destroy(), k.destroy(), M.clear()
                }

                function Z(t, e, i) {
                    N.active && !I && (n.scrollBody.useBaseFriction().useDuration(!0 === e ? 0 : N.duration), n.scrollTo.index(t, i || 0))
                }

                function K() {
                    return n.index.get()
                }
                let Y = {
                    canScrollNext: function() {
                        return n.index.add(1).get() !== K()
                    },
                    canScrollPrev: function() {
                        return n.index.add(-1).get() !== K()
                    },
                    containerNode: function() {
                        return s
                    },
                    internalEngine: function() {
                        return n
                    },
                    destroy: function() {
                        I || (I = !0, M.clear(), H(), R.emit("destroy"), R.clear())
                    },
                    off: O,
                    on: F,
                    emit: B,
                    plugins: function() {
                        return r
                    },
                    previousScrollSnap: function() {
                        return n.indexPrevious.get()
                    },
                    reInit: z,
                    rootNode: function() {
                        return t
                    },
                    scrollNext: function(t) {
                        Z(n.index.add(1).get(), t, -1)
                    },
                    scrollPrev: function(t) {
                        Z(n.index.add(-1).get(), t, 1)
                    },
                    scrollProgress: function() {
                        return n.scrollProgress.get(n.location.get())
                    },
                    scrollSnapList: function() {
                        return n.scrollSnapList
                    },
                    scrollTo: Z,
                    selectedScrollSnap: K,
                    slideNodes: function() {
                        return o
                    },
                    slidesInView: function() {
                        return n.slidesInView.get()
                    },
                    slidesNotInView: function() {
                        return n.slidesInView.get(!1)
                    }
                };
                return W(e, i), setTimeout(() => R.emit("init"), 0), Y
            }

            function A(t = {}, e = []) {
                let i = (0, n.useRef)(t),
                    r = (0, n.useRef)(e),
                    [a, l] = (0, n.useState)(),
                    [u, h] = (0, n.useState)(),
                    c = (0, n.useCallback)(() => {
                        a && a.reInit(i.current, r.current)
                    }, [a]);
                return (0, n.useEffect)(() => {
                    if ("undefined" != typeof window && window.document && window.document.createElement && u) {
                        T.globalOptions = A.globalOptions;
                        let t = T(u, i.current, r.current);
                        return l(t), () => t.destroy()
                    }
                    l(void 0)
                }, [u, l]), (0, n.useEffect)(() => {
                    s(i.current, t) || (i.current = t, c())
                }, [t, c]), (0, n.useEffect)(() => {
                    ! function(t, e) {
                        if (t.length !== e.length) return !1;
                        let i = o(t),
                            n = o(e);
                        return i.every((t, e) => s(t, n[e]))
                    }(r.current, e) && (r.current = e, c())
                }, [e, c]), [h, a]
            }
            T.globalOptions = void 0, A.globalOptions = void 0
        },
        3981: function(t, e, i) {
            i.d(e, {
                M: function() {
                    return g
                }
            });
            var n = i(7949),
                r = i(6265),
                s = i(1958),
                o = i(8099),
                a = i(9082);
            class l extends r.Component {
                getSnapshotBeforeUpdate(t) {
                    let e = this.props.childRef.current;
                    if (e && t.isPresent && !this.props.isPresent) {
                        let t = this.props.sizeRef.current;
                        t.height = e.offsetHeight || 0, t.width = e.offsetWidth || 0, t.top = e.offsetTop, t.left = e.offsetLeft
                    }
                    return null
                }
                componentDidUpdate() {}
                render() {
                    return this.props.children
                }
            }

            function u({
                children: t,
                isPresent: e
            }) {
                let i = (0, r.useId)(),
                    s = (0, r.useRef)(null),
                    o = (0, r.useRef)({
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0
                    }),
                    {
                        nonce: u
                    } = (0, r.useContext)(a._);
                return (0, r.useInsertionEffect)(() => {
                    let {
                        width: t,
                        height: n,
                        top: r,
                        left: a
                    } = o.current;
                    if (e || !s.current || !t || !n) return;
                    s.current.dataset.motionPopId = i;
                    let l = document.createElement("style");
                    return u && (l.nonce = u), document.head.appendChild(l), l.sheet && l.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${t}px !important;
            height: ${n}px !important;
            top: ${r}px !important;
            left: ${a}px !important;
          }
        `), () => {
                        document.head.removeChild(l)
                    }
                }, [e]), (0, n.jsx)(l, {
                    isPresent: e,
                    childRef: s,
                    sizeRef: o,
                    children: r.cloneElement(t, {
                        ref: s
                    })
                })
            }
            let h = ({
                children: t,
                initial: e,
                isPresent: i,
                onExitComplete: a,
                custom: l,
                presenceAffectsLayout: h,
                mode: d
            }) => {
                let p = (0, o.h)(c),
                    f = (0, r.useId)(),
                    m = (0, r.useMemo)(() => ({
                        id: f,
                        initial: e,
                        isPresent: i,
                        custom: l,
                        onExitComplete: t => {
                            for (let e of (p.set(t, !0), p.values()))
                                if (!e) return;
                            a && a()
                        },
                        register: t => (p.set(t, !1), () => p.delete(t))
                    }), h ? [Math.random()] : [i]);
                return (0, r.useMemo)(() => {
                    p.forEach((t, e) => p.set(e, !1))
                }, [i]), r.useEffect(() => {
                    i || p.size || !a || a()
                }, [i]), "popLayout" === d && (t = (0, n.jsx)(u, {
                    isPresent: i,
                    children: t
                })), (0, n.jsx)(s.O.Provider, {
                    value: m,
                    children: t
                })
            };

            function c() {
                return new Map
            }
            var d = i(7816),
                p = i(4188);
            let f = t => t.key || "";

            function m(t) {
                let e = [];
                return r.Children.forEach(t, t => {
                    (0, r.isValidElement)(t) && e.push(t)
                }), e
            }
            var v = i(805);
            let g = ({
                children: t,
                exitBeforeEnter: e,
                custom: i,
                initial: s = !0,
                onExitComplete: a,
                presenceAffectsLayout: l = !0,
                mode: u = "sync"
            }) => {
                (0, p.k)(!e, "Replace exitBeforeEnter with mode='wait'");
                let c = (0, r.useMemo)(() => m(t), [t]),
                    g = c.map(f),
                    y = (0, r.useRef)(!0),
                    x = (0, r.useRef)(c),
                    b = (0, o.h)(() => new Map),
                    [w, P] = (0, r.useState)(c),
                    [S, T] = (0, r.useState)(c);
                (0, v.L)(() => {
                    y.current = !1, x.current = c;
                    for (let t = 0; t < S.length; t++) {
                        let e = f(S[t]);
                        g.includes(e) ? b.delete(e) : !0 !== b.get(e) && b.set(e, !1)
                    }
                }, [S, g.length, g.join("-")]);
                let A = [];
                if (c !== w) {
                    let t = [...c];
                    for (let e = 0; e < S.length; e++) {
                        let i = S[e],
                            n = f(i);
                        g.includes(n) || (t.splice(e, 0, i), A.push(i))
                    }
                    "wait" === u && A.length && (t = A), T(m(t)), P(c);
                    return
                }
                let {
                    forceRender: E
                } = (0, r.useContext)(d.p);
                return (0, n.jsx)(n.Fragment, {
                    children: S.map(t => {
                        let e = f(t),
                            r = c === S || g.includes(e);
                        return (0, n.jsx)(h, {
                            isPresent: r,
                            initial: (!y.current || !!s) && void 0,
                            custom: r ? void 0 : i,
                            presenceAffectsLayout: l,
                            mode: u,
                            onExitComplete: r ? void 0 : () => {
                                if (!b.has(e)) return;
                                b.set(e, !0);
                                let t = !0;
                                b.forEach(e => {
                                    e || (t = !1)
                                }), t && (null == E || E(), T(x.current), a && a())
                            },
                            children: t
                        }, e)
                    })
                })
            }
        },
        7816: function(t, e, i) {
            i.d(e, {
                p: function() {
                    return n
                }
            });
            let n = (0, i(6265).createContext)({})
        },
        9082: function(t, e, i) {
            i.d(e, {
                _: function() {
                    return n
                }
            });
            let n = (0, i(6265).createContext)({
                transformPagePoint: t => t,
                isStatic: !1,
                reducedMotion: "never"
            })
        },
        1958: function(t, e, i) {
            i.d(e, {
                O: function() {
                    return n
                }
            });
            let n = (0, i(6265).createContext)(null)
        },
        1619: function(t, e, i) {
            let n;
            i.d(e, {
                E: function() {
                    return sh
                }
            });
            var r, s = i(7949),
                o = i(6265),
                a = i(9082);
            let l = (0, o.createContext)({});
            var u = i(1958),
                h = i(805);
            let c = (0, o.createContext)({
                    strict: !1
                }),
                d = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
                p = "data-" + d("framerAppearId"),
                f = {
                    skipAnimations: !1,
                    useManualTiming: !1
                },
                m = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"];

            function v(t, e) {
                let i = !1,
                    n = !0,
                    r = {
                        delta: 0,
                        timestamp: 0,
                        isProcessing: !1
                    },
                    s = () => i = !0,
                    o = m.reduce((t, e) => (t[e] = function(t) {
                        let e = new Set,
                            i = new Set,
                            n = !1,
                            r = !1,
                            s = new WeakSet,
                            o = {
                                delta: 0,
                                timestamp: 0,
                                isProcessing: !1
                            };

                        function a(e) {
                            s.has(e) && (l.schedule(e), t()), e(o)
                        }
                        let l = {
                            schedule: (t, r = !1, o = !1) => {
                                let a = o && n ? e : i;
                                return r && s.add(t), a.has(t) || a.add(t), t
                            },
                            cancel: t => {
                                i.delete(t), s.delete(t)
                            },
                            process: t => {
                                if (o = t, n) {
                                    r = !0;
                                    return
                                }
                                n = !0, [e, i] = [i, e], i.clear(), e.forEach(a), n = !1, r && (r = !1, l.process(t))
                            }
                        };
                        return l
                    }(s), t), {}),
                    {
                        read: a,
                        resolveKeyframes: l,
                        update: u,
                        preRender: h,
                        render: c,
                        postRender: d
                    } = o,
                    p = () => {
                        let s = f.useManualTiming ? r.timestamp : performance.now();
                        i = !1, r.delta = n ? 1e3 / 60 : Math.max(Math.min(s - r.timestamp, 40), 1), r.timestamp = s, r.isProcessing = !0, a.process(r), l.process(r), u.process(r), h.process(r), c.process(r), d.process(r), r.isProcessing = !1, i && e && (n = !1, t(p))
                    },
                    v = () => {
                        i = !0, n = !0, r.isProcessing || t(p)
                    };
                return {
                    schedule: m.reduce((t, e) => {
                        let n = o[e];
                        return t[e] = (t, e = !1, r = !1) => (i || v(), n.schedule(t, e, r)), t
                    }, {}),
                    cancel: t => {
                        for (let e = 0; e < m.length; e++) o[m[e]].cancel(t)
                    },
                    state: r,
                    steps: o
                }
            }
            let {
                schedule: g,
                cancel: y
            } = v(queueMicrotask, !1);

            function x(t) {
                return t && "object" == typeof t && Object.prototype.hasOwnProperty.call(t, "current")
            }
            let b = (0, o.createContext)({}),
                w = !1;

            function P() {
                window.HandoffComplete = !0
            }

            function S(t) {
                return "string" == typeof t || Array.isArray(t)
            }

            function T(t) {
                return null !== t && "object" == typeof t && "function" == typeof t.start
            }
            let A = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
                E = ["initial", ...A];

            function C(t) {
                return T(t.animate) || E.some(e => S(t[e]))
            }

            function V(t) {
                return !!(C(t) || t.variants)
            }

            function k(t) {
                return Array.isArray(t) ? t.join(" ") : t
            }
            let M = {
                    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
                    exit: ["exit"],
                    drag: ["drag", "dragControls"],
                    focus: ["whileFocus"],
                    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
                    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
                    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
                    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
                    layout: ["layout", "layoutId"]
                },
                R = {};
            for (let t in M) R[t] = {
                isEnabled: e => M[t].some(t => !!e[t])
            };
            var D = i(7691),
                j = i(7816);
            let L = Symbol.for("motionComponentSymbol"),
                F = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

            function O(t) {
                if ("string" != typeof t || t.includes("-"));
                else if (F.indexOf(t) > -1 || /[A-Z]/u.test(t)) return !0;
                return !1
            }
            let B = {},
                I = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
                U = new Set(I);

            function N(t, {
                layout: e,
                layoutId: i
            }) {
                return U.has(t) || t.startsWith("origin") || (e || void 0 !== i) && (!!B[t] || "opacity" === t)
            }
            let $ = t => !!(t && t.getVelocity),
                W = (t, e) => e && "number" == typeof t ? e.transform(t) : t,
                z = (t, e, i) => i > e ? e : i < t ? t : i,
                H = {
                    test: t => "number" == typeof t,
                    parse: parseFloat,
                    transform: t => t
                },
                Z = { ...H,
                    transform: t => z(0, 1, t)
                },
                K = { ...H,
                    default: 1
                },
                Y = t => Math.round(1e5 * t) / 1e5,
                _ = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
                X = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
                q = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

            function G(t) {
                return "string" == typeof t
            }
            let J = t => ({
                    test: e => G(e) && e.endsWith(t) && 1 === e.split(" ").length,
                    parse: parseFloat,
                    transform: e => `${e}${t}`
                }),
                Q = J("deg"),
                tt = J("%"),
                te = J("px"),
                ti = J("vh"),
                tn = J("vw"),
                tr = { ...tt,
                    parse: t => tt.parse(t) / 100,
                    transform: t => tt.transform(100 * t)
                },
                ts = { ...H,
                    transform: Math.round
                },
                to = {
                    borderWidth: te,
                    borderTopWidth: te,
                    borderRightWidth: te,
                    borderBottomWidth: te,
                    borderLeftWidth: te,
                    borderRadius: te,
                    radius: te,
                    borderTopLeftRadius: te,
                    borderTopRightRadius: te,
                    borderBottomRightRadius: te,
                    borderBottomLeftRadius: te,
                    width: te,
                    maxWidth: te,
                    height: te,
                    maxHeight: te,
                    size: te,
                    top: te,
                    right: te,
                    bottom: te,
                    left: te,
                    padding: te,
                    paddingTop: te,
                    paddingRight: te,
                    paddingBottom: te,
                    paddingLeft: te,
                    margin: te,
                    marginTop: te,
                    marginRight: te,
                    marginBottom: te,
                    marginLeft: te,
                    rotate: Q,
                    rotateX: Q,
                    rotateY: Q,
                    rotateZ: Q,
                    scale: K,
                    scaleX: K,
                    scaleY: K,
                    scaleZ: K,
                    skew: Q,
                    skewX: Q,
                    skewY: Q,
                    distance: te,
                    translateX: te,
                    translateY: te,
                    translateZ: te,
                    x: te,
                    y: te,
                    z: te,
                    perspective: te,
                    transformPerspective: te,
                    opacity: Z,
                    originX: tr,
                    originY: tr,
                    originZ: te,
                    zIndex: ts,
                    backgroundPositionX: te,
                    backgroundPositionY: te,
                    fillOpacity: Z,
                    strokeOpacity: Z,
                    numOctaves: ts
                },
                ta = {
                    x: "translateX",
                    y: "translateY",
                    z: "translateZ",
                    transformPerspective: "perspective"
                },
                tl = I.length,
                tu = t => e => "string" == typeof e && e.startsWith(t),
                th = tu("--"),
                tc = tu("var(--"),
                td = t => !!tc(t) && tp.test(t.split("/*")[0].trim()),
                tp = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

            function tf(t, e, i) {
                let {
                    style: n,
                    vars: r,
                    transformOrigin: s
                } = t, o = !1, a = !1;
                for (let t in e) {
                    let i = e[t];
                    if (U.has(t)) {
                        o = !0;
                        continue
                    }
                    if (th(t)) {
                        r[t] = i;
                        continue
                    } {
                        let e = W(i, to[t]);
                        t.startsWith("origin") ? (a = !0, s[t] = e) : n[t] = e
                    }
                }
                if (!e.transform && (o || i ? n.transform = function(t, e, i) {
                        let n = "",
                            r = !0;
                        for (let s = 0; s < tl; s++) {
                            let o = I[s],
                                a = t[o];
                            if (void 0 === a) continue;
                            let l = !0;
                            if (!(l = "number" == typeof a ? a === (o.startsWith("scale") ? 1 : 0) : 0 === parseFloat(a)) || i) {
                                let t = W(a, to[o]);
                                if (!l) {
                                    r = !1;
                                    let e = ta[o] || o;
                                    n += `${e}(${t}) `
                                }
                                i && (e[o] = t)
                            }
                        }
                        return n = n.trim(), i ? n = i(e, r ? "" : n) : r && (n = "none"), n
                    }(e, t.transform, i) : n.transform && (n.transform = "none")), a) {
                    let {
                        originX: t = "50%",
                        originY: e = "50%",
                        originZ: i = 0
                    } = s;
                    n.transformOrigin = `${t} ${e} ${i}`
                }
            }
            let tm = () => ({
                style: {},
                transform: {},
                transformOrigin: {},
                vars: {}
            });

            function tv(t, e, i) {
                for (let n in e) $(e[n]) || N(n, i) || (t[n] = e[n])
            }
            let tg = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

            function ty(t) {
                return t.startsWith("while") || t.startsWith("drag") && "draggable" !== t || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || tg.has(t)
            }
            let tx = t => !ty(t);
            try {
                (r = require("@emotion/is-prop-valid").default) && (tx = t => t.startsWith("on") ? !ty(t) : r(t))
            } catch (t) {}

            function tb(t, e, i) {
                return "string" == typeof t ? t : te.transform(e + i * t)
            }
            let tw = {
                    offset: "stroke-dashoffset",
                    array: "stroke-dasharray"
                },
                tP = {
                    offset: "strokeDashoffset",
                    array: "strokeDasharray"
                };

            function tS(t, {
                attrX: e,
                attrY: i,
                attrScale: n,
                originX: r,
                originY: s,
                pathLength: o,
                pathSpacing: a = 1,
                pathOffset: l = 0,
                ...u
            }, h, c) {
                if (tf(t, u, c), h) {
                    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
                    return
                }
                t.attrs = t.style, t.style = {};
                let {
                    attrs: d,
                    style: p,
                    dimensions: f
                } = t;
                d.transform && (f && (p.transform = d.transform), delete d.transform), f && (void 0 !== r || void 0 !== s || p.transform) && (p.transformOrigin = function(t, e, i) {
                    let n = tb(e, t.x, t.width),
                        r = tb(i, t.y, t.height);
                    return `${n} ${r}`
                }(f, void 0 !== r ? r : .5, void 0 !== s ? s : .5)), void 0 !== e && (d.x = e), void 0 !== i && (d.y = i), void 0 !== n && (d.scale = n), void 0 !== o && function(t, e, i = 1, n = 0, r = !0) {
                    t.pathLength = 1;
                    let s = r ? tw : tP;
                    t[s.offset] = te.transform(-n);
                    let o = te.transform(e),
                        a = te.transform(i);
                    t[s.array] = `${o} ${a}`
                }(d, o, a, l, !1)
            }
            let tT = () => ({ ...tm(),
                    attrs: {}
                }),
                tA = t => "string" == typeof t && "svg" === t.toLowerCase();

            function tE(t, {
                style: e,
                vars: i
            }, n, r) {
                for (let s in Object.assign(t.style, e, r && r.getProjectionStyles(n)), i) t.style.setProperty(s, i[s])
            }
            let tC = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

            function tV(t, e, i, n) {
                for (let i in tE(t, e, void 0, n), e.attrs) t.setAttribute(tC.has(i) ? i : d(i), e.attrs[i])
            }

            function tk(t, e, i) {
                var n;
                let {
                    style: r
                } = t, s = {};
                for (let o in r)($(r[o]) || e.style && $(e.style[o]) || N(o, t) || (null === (n = null == i ? void 0 : i.getValue(o)) || void 0 === n ? void 0 : n.liveStyle) !== void 0) && (s[o] = r[o]);
                return i && r && "string" == typeof r.willChange && (i.applyWillChange = !1), s
            }

            function tM(t, e, i) {
                let n = tk(t, e, i);
                for (let i in t)($(t[i]) || $(e[i])) && (n[-1 !== I.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = t[i]);
                return n
            }

            function tR(t) {
                let e = [{}, {}];
                return null == t || t.values.forEach((t, i) => {
                    e[0][i] = t.get(), e[1][i] = t.getVelocity()
                }), e
            }

            function tD(t, e, i, n) {
                if ("function" == typeof e) {
                    let [r, s] = tR(n);
                    e = e(void 0 !== i ? i : t.custom, r, s)
                }
                if ("string" == typeof e && (e = t.variants && t.variants[e]), "function" == typeof e) {
                    let [r, s] = tR(n);
                    e = e(void 0 !== i ? i : t.custom, r, s)
                }
                return e
            }
            var tj = i(8099);
            let tL = t => Array.isArray(t),
                tF = t => !!(t && "object" == typeof t && t.mix && t.toValue),
                tO = t => tL(t) ? t[t.length - 1] || 0 : t;

            function tB(t) {
                let e = $(t) ? t.get() : t;
                return tF(e) ? e.toValue() : e
            }
            let tI = new Set(["opacity", "clipPath", "filter", "transform"]);

            function tU(t) {
                return U.has(t) ? "transform" : tI.has(t) ? d(t) : void 0
            }

            function tN(t, e) {
                -1 === t.indexOf(e) && t.push(e)
            }

            function t$(t, e) {
                let i = t.indexOf(e);
                i > -1 && t.splice(i, 1)
            }
            let tW = t => (e, i) => {
                let n = (0, o.useContext)(l),
                    r = (0, o.useContext)(u.O),
                    s = () => (function({
                        applyWillChange: t = !1,
                        scrapeMotionValuesFromProps: e,
                        createRenderState: i,
                        onMount: n
                    }, r, s, o, a) {
                        let l = {
                            latestValues: function(t, e, i, n, r) {
                                var s;
                                let o = {},
                                    a = [],
                                    l = n && (null === (s = t.style) || void 0 === s ? void 0 : s.willChange) === void 0,
                                    u = r(t, {});
                                for (let t in u) o[t] = tB(u[t]);
                                let {
                                    initial: h,
                                    animate: c
                                } = t, d = C(t), p = V(t);
                                e && p && !d && !1 !== t.inherit && (void 0 === h && (h = e.initial), void 0 === c && (c = e.animate));
                                let f = !!i && !1 === i.initial,
                                    m = (f = f || !1 === h) ? c : h;
                                return m && "boolean" != typeof m && !T(m) && tz(t, m, (t, e) => {
                                    for (let e in t) {
                                        let i = t[e];
                                        if (Array.isArray(i)) {
                                            let t = f ? i.length - 1 : 0;
                                            i = i[t]
                                        }
                                        null !== i && (o[e] = i)
                                    }
                                    for (let t in e) o[t] = e[t]
                                }), l && (c && !1 !== h && !T(c) && tz(t, c, t => {
                                    for (let e in t) ! function(t, e) {
                                        let i = tU(e);
                                        i && tN(t, i)
                                    }(a, e)
                                }), a.length && (o.willChange = a.join(","))), o
                            }(r, s, o, !a && t, e),
                            renderState: i()
                        };
                        return n && (l.mount = t => n(r, t, l)), l
                    })(t, e, n, r, i);
                return i ? s() : (0, tj.h)(s)
            };

            function tz(t, e, i) {
                let n = Array.isArray(e) ? e : [e];
                for (let e = 0; e < n.length; e++) {
                    let r = tD(t, n[e]);
                    if (r) {
                        let {
                            transitionEnd: t,
                            transition: e,
                            ...n
                        } = r;
                        i(n, t)
                    }
                }
            }
            var tH = i(7678);
            let {
                schedule: tZ,
                cancel: tK,
                state: tY,
                steps: t_
            } = v("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : tH.Z, !0), tX = {
                useVisualState: tW({
                    scrapeMotionValuesFromProps: tM,
                    createRenderState: tT,
                    onMount: (t, e, {
                        renderState: i,
                        latestValues: n
                    }) => {
                        tZ.read(() => {
                            try {
                                i.dimensions = "function" == typeof e.getBBox ? e.getBBox() : e.getBoundingClientRect()
                            } catch (t) {
                                i.dimensions = {
                                    x: 0,
                                    y: 0,
                                    width: 0,
                                    height: 0
                                }
                            }
                        }), tZ.render(() => {
                            tS(i, n, tA(e.tagName), t.transformTemplate), tV(e, i)
                        })
                    }
                })
            }, tq = {
                useVisualState: tW({
                    applyWillChange: !0,
                    scrapeMotionValuesFromProps: tk,
                    createRenderState: tm
                })
            };

            function tG(t, e, i, n = {
                passive: !0
            }) {
                return t.addEventListener(e, i, n), () => t.removeEventListener(e, i)
            }
            let tJ = t => "mouse" === t.pointerType ? "number" != typeof t.button || t.button <= 0 : !1 !== t.isPrimary;

            function tQ(t, e = "page") {
                return {
                    point: {
                        x: t[`${e}X`],
                        y: t[`${e}Y`]
                    }
                }
            }
            let t0 = t => e => tJ(e) && t(e, tQ(e));

            function t1(t, e, i, n) {
                return tG(t, e, t0(i), n)
            }
            let t2 = (t, e) => i => e(t(i)),
                t5 = (...t) => t.reduce(t2);

            function t9(t) {
                let e = null;
                return () => null === e && (e = t, () => {
                    e = null
                })
            }
            let t6 = t9("dragHorizontal"),
                t3 = t9("dragVertical");

            function t8(t) {
                let e = !1;
                if ("y" === t) e = t3();
                else if ("x" === t) e = t6();
                else {
                    let t = t6(),
                        i = t3();
                    t && i ? e = () => {
                        t(), i()
                    } : (t && t(), i && i())
                }
                return e
            }

            function t4() {
                let t = t8(!0);
                return !t || (t(), !1)
            }
            class t7 {
                constructor(t) {
                    this.isMounted = !1, this.node = t
                }
                update() {}
            }

            function et(t, e) {
                let i = e ? "onHoverStart" : "onHoverEnd";
                return t1(t.current, e ? "pointerenter" : "pointerleave", (n, r) => {
                    if ("touch" === n.pointerType || t4()) return;
                    let s = t.getProps();
                    t.animationState && s.whileHover && t.animationState.setActive("whileHover", e);
                    let o = s[i];
                    o && tZ.postRender(() => o(n, r))
                }, {
                    passive: !t.getProps()[i]
                })
            }
            class ee extends t7 {
                mount() {
                    this.unmount = t5(et(this.node, !0), et(this.node, !1))
                }
                unmount() {}
            }
            class ei extends t7 {
                constructor() {
                    super(...arguments), this.isActive = !1
                }
                onFocus() {
                    let t = !1;
                    try {
                        t = this.node.current.matches(":focus-visible")
                    } catch (e) {
                        t = !0
                    }
                    t && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
                }
                onBlur() {
                    this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
                }
                mount() {
                    this.unmount = t5(tG(this.node.current, "focus", () => this.onFocus()), tG(this.node.current, "blur", () => this.onBlur()))
                }
                unmount() {}
            }
            let en = (t, e) => !!e && (t === e || en(t, e.parentElement));

            function er(t, e) {
                if (!e) return;
                let i = new PointerEvent("pointer" + t);
                e(i, tQ(i))
            }
            class es extends t7 {
                constructor() {
                    super(...arguments), this.removeStartListeners = tH.Z, this.removeEndListeners = tH.Z, this.removeAccessibleListeners = tH.Z, this.startPointerPress = (t, e) => {
                        if (this.isPressing) return;
                        this.removeEndListeners();
                        let i = this.node.getProps(),
                            n = t1(window, "pointerup", (t, e) => {
                                if (!this.checkPressEnd()) return;
                                let {
                                    onTap: i,
                                    onTapCancel: n,
                                    globalTapTarget: r
                                } = this.node.getProps(), s = r || en(this.node.current, t.target) ? i : n;
                                s && tZ.update(() => s(t, e))
                            }, {
                                passive: !(i.onTap || i.onPointerUp)
                            }),
                            r = t1(window, "pointercancel", (t, e) => this.cancelPress(t, e), {
                                passive: !(i.onTapCancel || i.onPointerCancel)
                            });
                        this.removeEndListeners = t5(n, r), this.startPress(t, e)
                    }, this.startAccessiblePress = () => {
                        let t = tG(this.node.current, "keydown", t => {
                                "Enter" !== t.key || this.isPressing || (this.removeEndListeners(), this.removeEndListeners = tG(this.node.current, "keyup", t => {
                                    "Enter" === t.key && this.checkPressEnd() && er("up", (t, e) => {
                                        let {
                                            onTap: i
                                        } = this.node.getProps();
                                        i && tZ.postRender(() => i(t, e))
                                    })
                                }), er("down", (t, e) => {
                                    this.startPress(t, e)
                                }))
                            }),
                            e = tG(this.node.current, "blur", () => {
                                this.isPressing && er("cancel", (t, e) => this.cancelPress(t, e))
                            });
                        this.removeAccessibleListeners = t5(t, e)
                    }
                }
                startPress(t, e) {
                    this.isPressing = !0;
                    let {
                        onTapStart: i,
                        whileTap: n
                    } = this.node.getProps();
                    n && this.node.animationState && this.node.animationState.setActive("whileTap", !0), i && tZ.postRender(() => i(t, e))
                }
                checkPressEnd() {
                    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !t4()
                }
                cancelPress(t, e) {
                    if (!this.checkPressEnd()) return;
                    let {
                        onTapCancel: i
                    } = this.node.getProps();
                    i && tZ.postRender(() => i(t, e))
                }
                mount() {
                    let t = this.node.getProps(),
                        e = t1(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
                            passive: !(t.onTapStart || t.onPointerStart)
                        }),
                        i = tG(this.node.current, "focus", this.startAccessiblePress);
                    this.removeStartListeners = t5(e, i)
                }
                unmount() {
                    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
                }
            }
            let eo = new WeakMap,
                ea = new WeakMap,
                el = t => {
                    let e = eo.get(t.target);
                    e && e(t)
                },
                eu = t => {
                    t.forEach(el)
                },
                eh = {
                    some: 0,
                    all: 1
                };
            class ec extends t7 {
                constructor() {
                    super(...arguments), this.hasEnteredView = !1, this.isInView = !1
                }
                startObserver() {
                    this.unmount();
                    let {
                        viewport: t = {}
                    } = this.node.getProps(), {
                        root: e,
                        margin: i,
                        amount: n = "some",
                        once: r
                    } = t, s = {
                        root: e ? e.current : void 0,
                        rootMargin: i,
                        threshold: "number" == typeof n ? n : eh[n]
                    };
                    return function(t, e, i) {
                        let n = function({
                            root: t,
                            ...e
                        }) {
                            let i = t || document;
                            ea.has(i) || ea.set(i, {});
                            let n = ea.get(i),
                                r = JSON.stringify(e);
                            return n[r] || (n[r] = new IntersectionObserver(eu, {
                                root: t,
                                ...e
                            })), n[r]
                        }(e);
                        return eo.set(t, i), n.observe(t), () => {
                            eo.delete(t), n.unobserve(t)
                        }
                    }(this.node.current, s, t => {
                        let {
                            isIntersecting: e
                        } = t;
                        if (this.isInView === e || (this.isInView = e, r && !e && this.hasEnteredView)) return;
                        e && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", e);
                        let {
                            onViewportEnter: i,
                            onViewportLeave: n
                        } = this.node.getProps(), s = e ? i : n;
                        s && s(t)
                    })
                }
                mount() {
                    this.startObserver()
                }
                update() {
                    if ("undefined" == typeof IntersectionObserver) return;
                    let {
                        props: t,
                        prevProps: e
                    } = this.node;
                    ["amount", "margin", "root"].some(function({
                        viewport: t = {}
                    }, {
                        viewport: e = {}
                    } = {}) {
                        return i => t[i] !== e[i]
                    }(t, e)) && this.startObserver()
                }
                unmount() {}
            }

            function ed(t, e) {
                if (!Array.isArray(e)) return !1;
                let i = e.length;
                if (i !== t.length) return !1;
                for (let n = 0; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function ep(t, e, i) {
                let n = t.getProps();
                return tD(n, e, void 0 !== i ? i : n.custom, t)
            }
            let ef = t => 1e3 * t,
                em = t => t / 1e3,
                ev = {
                    type: "spring",
                    stiffness: 500,
                    damping: 25,
                    restSpeed: 10
                },
                eg = t => ({
                    type: "spring",
                    stiffness: 550,
                    damping: 0 === t ? 2 * Math.sqrt(550) : 30,
                    restSpeed: 10
                }),
                ey = {
                    type: "keyframes",
                    duration: .8
                },
                ex = {
                    type: "keyframes",
                    ease: [.25, .1, .35, 1],
                    duration: .3
                },
                eb = (t, {
                    keyframes: e
                }) => e.length > 2 ? ey : U.has(t) ? t.startsWith("scale") ? eg(e[1]) : ev : ex;

            function ew(t, e) {
                return t[e] || t.default || t
            }
            let eP = {
                    current: !1
                },
                eS = t => null !== t;

            function eT(t, {
                repeat: e,
                repeatType: i = "loop"
            }, n) {
                let r = t.filter(eS),
                    s = e && "loop" !== i && e % 2 == 1 ? 0 : r.length - 1;
                return s && void 0 !== n ? n : r[s]
            }

            function eA() {
                n = void 0
            }
            let eE = {
                    now: () => (void 0 === n && eE.set(tY.isProcessing || f.useManualTiming ? tY.timestamp : performance.now()), n),
                    set: t => {
                        n = t, queueMicrotask(eA)
                    }
                },
                eC = t => /^0[^.\s]+$/u.test(t);
            var eV = i(4188);
            let ek = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
                eM = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u,
                eR = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
                eD = t => t === H || t === te,
                ej = (t, e) => parseFloat(t.split(", ")[e]),
                eL = (t, e) => (i, {
                    transform: n
                }) => {
                    if ("none" === n || !n) return 0;
                    let r = n.match(/^matrix3d\((.+)\)$/u);
                    if (r) return ej(r[1], e); {
                        let e = n.match(/^matrix\((.+)\)$/u);
                        return e ? ej(e[1], t) : 0
                    }
                },
                eF = new Set(["x", "y", "z"]),
                eO = I.filter(t => !eF.has(t)),
                eB = {
                    width: ({
                        x: t
                    }, {
                        paddingLeft: e = "0",
                        paddingRight: i = "0"
                    }) => t.max - t.min - parseFloat(e) - parseFloat(i),
                    height: ({
                        y: t
                    }, {
                        paddingTop: e = "0",
                        paddingBottom: i = "0"
                    }) => t.max - t.min - parseFloat(e) - parseFloat(i),
                    top: (t, {
                        top: e
                    }) => parseFloat(e),
                    left: (t, {
                        left: e
                    }) => parseFloat(e),
                    bottom: ({
                        y: t
                    }, {
                        top: e
                    }) => parseFloat(e) + (t.max - t.min),
                    right: ({
                        x: t
                    }, {
                        left: e
                    }) => parseFloat(e) + (t.max - t.min),
                    x: eL(4, 13),
                    y: eL(5, 14)
                };
            eB.translateX = eB.x, eB.translateY = eB.y;
            let eI = t => e => e.test(t),
                eU = [H, te, tt, Q, tn, ti, {
                    test: t => "auto" === t,
                    parse: t => t
                }],
                eN = t => eU.find(eI(t)),
                e$ = new Set,
                eW = !1,
                ez = !1;

            function eH() {
                if (ez) {
                    let t = Array.from(e$).filter(t => t.needsMeasurement),
                        e = new Set(t.map(t => t.element)),
                        i = new Map;
                    e.forEach(t => {
                        let e = function(t) {
                            let e = [];
                            return eO.forEach(i => {
                                let n = t.getValue(i);
                                void 0 !== n && (e.push([i, n.get()]), n.set(i.startsWith("scale") ? 1 : 0))
                            }), e
                        }(t);
                        e.length && (i.set(t, e), t.render())
                    }), t.forEach(t => t.measureInitialState()), e.forEach(t => {
                        t.render();
                        let e = i.get(t);
                        e && e.forEach(([e, i]) => {
                            var n;
                            null === (n = t.getValue(e)) || void 0 === n || n.set(i)
                        })
                    }), t.forEach(t => t.measureEndState()), t.forEach(t => {
                        void 0 !== t.suspendedScrollY && window.scrollTo(0, t.suspendedScrollY)
                    })
                }
                ez = !1, eW = !1, e$.forEach(t => t.complete()), e$.clear()
            }

            function eZ() {
                e$.forEach(t => {
                    t.readKeyframes(), t.needsMeasurement && (ez = !0)
                })
            }
            class eK {
                constructor(t, e, i, n, r, s = !1) {
                    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = e, this.name = i, this.motionValue = n, this.element = r, this.isAsync = s
                }
                scheduleResolve() {
                    this.isScheduled = !0, this.isAsync ? (e$.add(this), eW || (eW = !0, tZ.read(eZ), tZ.resolveKeyframes(eH))) : (this.readKeyframes(), this.complete())
                }
                readKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        name: e,
                        element: i,
                        motionValue: n
                    } = this;
                    for (let r = 0; r < t.length; r++)
                        if (null === t[r]) {
                            if (0 === r) {
                                let r = null == n ? void 0 : n.get(),
                                    s = t[t.length - 1];
                                if (void 0 !== r) t[0] = r;
                                else if (i && e) {
                                    let n = i.readValue(e, s);
                                    null != n && (t[0] = n)
                                }
                                void 0 === t[0] && (t[0] = s), n && void 0 === r && n.set(t[0])
                            } else t[r] = t[r - 1]
                        }
                }
                setFinalKeyframe() {}
                measureInitialState() {}
                renderEndStyles() {}
                measureEndState() {}
                complete() {
                    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), e$.delete(this)
                }
                cancel() {
                    this.isComplete || (this.isScheduled = !1, e$.delete(this))
                }
                resume() {
                    this.isComplete || this.scheduleResolve()
                }
            }
            let eY = (t, e) => i => !!(G(i) && q.test(i) && i.startsWith(t) || e && null != i && Object.prototype.hasOwnProperty.call(i, e)),
                e_ = (t, e, i) => n => {
                    if (!G(n)) return n;
                    let [r, s, o, a] = n.match(_);
                    return {
                        [t]: parseFloat(r),
                        [e]: parseFloat(s),
                        [i]: parseFloat(o),
                        alpha: void 0 !== a ? parseFloat(a) : 1
                    }
                },
                eX = t => z(0, 255, t),
                eq = { ...H,
                    transform: t => Math.round(eX(t))
                },
                eG = {
                    test: eY("rgb", "red"),
                    parse: e_("red", "green", "blue"),
                    transform: ({
                        red: t,
                        green: e,
                        blue: i,
                        alpha: n = 1
                    }) => "rgba(" + eq.transform(t) + ", " + eq.transform(e) + ", " + eq.transform(i) + ", " + Y(Z.transform(n)) + ")"
                },
                eJ = {
                    test: eY("#"),
                    parse: function(t) {
                        let e = "",
                            i = "",
                            n = "",
                            r = "";
                        return t.length > 5 ? (e = t.substring(1, 3), i = t.substring(3, 5), n = t.substring(5, 7), r = t.substring(7, 9)) : (e = t.substring(1, 2), i = t.substring(2, 3), n = t.substring(3, 4), r = t.substring(4, 5), e += e, i += i, n += n, r += r), {
                            red: parseInt(e, 16),
                            green: parseInt(i, 16),
                            blue: parseInt(n, 16),
                            alpha: r ? parseInt(r, 16) / 255 : 1
                        }
                    },
                    transform: eG.transform
                },
                eQ = {
                    test: eY("hsl", "hue"),
                    parse: e_("hue", "saturation", "lightness"),
                    transform: ({
                        hue: t,
                        saturation: e,
                        lightness: i,
                        alpha: n = 1
                    }) => "hsla(" + Math.round(t) + ", " + tt.transform(Y(e)) + ", " + tt.transform(Y(i)) + ", " + Y(Z.transform(n)) + ")"
                },
                e0 = {
                    test: t => eG.test(t) || eJ.test(t) || eQ.test(t),
                    parse: t => eG.test(t) ? eG.parse(t) : eQ.test(t) ? eQ.parse(t) : eJ.parse(t),
                    transform: t => G(t) ? t : t.hasOwnProperty("red") ? eG.transform(t) : eQ.transform(t)
                },
                e1 = "number",
                e2 = "color",
                e5 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

            function e9(t) {
                let e = t.toString(),
                    i = [],
                    n = {
                        color: [],
                        number: [],
                        var: []
                    },
                    r = [],
                    s = 0,
                    o = e.replace(e5, t => (e0.test(t) ? (n.color.push(s), r.push(e2), i.push(e0.parse(t))) : t.startsWith("var(") ? (n.var.push(s), r.push("var"), i.push(t)) : (n.number.push(s), r.push(e1), i.push(parseFloat(t))), ++s, "${}")).split("${}");
                return {
                    values: i,
                    split: o,
                    indexes: n,
                    types: r
                }
            }

            function e6(t) {
                return e9(t).values
            }

            function e3(t) {
                let {
                    split: e,
                    types: i
                } = e9(t), n = e.length;
                return t => {
                    let r = "";
                    for (let s = 0; s < n; s++)
                        if (r += e[s], void 0 !== t[s]) {
                            let e = i[s];
                            e === e1 ? r += Y(t[s]) : e === e2 ? r += e0.transform(t[s]) : r += t[s]
                        }
                    return r
                }
            }
            let e8 = t => "number" == typeof t ? 0 : t,
                e4 = {
                    test: function(t) {
                        var e, i;
                        return isNaN(t) && G(t) && ((null === (e = t.match(_)) || void 0 === e ? void 0 : e.length) || 0) + ((null === (i = t.match(X)) || void 0 === i ? void 0 : i.length) || 0) > 0
                    },
                    parse: e6,
                    createTransformer: e3,
                    getAnimatableNone: function(t) {
                        let e = e6(t);
                        return e3(t)(e.map(e8))
                    }
                },
                e7 = new Set(["brightness", "contrast", "saturate", "opacity"]);

            function it(t) {
                let [e, i] = t.slice(0, -1).split("(");
                if ("drop-shadow" === e) return t;
                let [n] = i.match(_) || [];
                if (!n) return t;
                let r = i.replace(n, ""),
                    s = e7.has(e) ? 1 : 0;
                return n !== i && (s *= 100), e + "(" + s + r + ")"
            }
            let ie = /\b([a-z-]*)\(.*?\)/gu,
                ii = { ...e4,
                    getAnimatableNone: t => {
                        let e = t.match(ie);
                        return e ? e.map(it).join(" ") : t
                    }
                },
                ir = { ...to,
                    color: e0,
                    backgroundColor: e0,
                    outlineColor: e0,
                    fill: e0,
                    stroke: e0,
                    borderColor: e0,
                    borderTopColor: e0,
                    borderRightColor: e0,
                    borderBottomColor: e0,
                    borderLeftColor: e0,
                    filter: ii,
                    WebkitFilter: ii
                },
                is = t => ir[t];

            function io(t, e) {
                let i = is(t);
                return i !== ii && (i = e4), i.getAnimatableNone ? i.getAnimatableNone(e) : void 0
            }
            let ia = new Set(["auto", "none", "0"]);
            class il extends eK {
                constructor(t, e, i, n) {
                    super(t, e, i, n, null == n ? void 0 : n.owner, !0)
                }
                readKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        element: e,
                        name: i
                    } = this;
                    if (!e.current) return;
                    super.readKeyframes();
                    for (let i = 0; i < t.length; i++) {
                        let n = t[i];
                        if ("string" == typeof n && td(n = n.trim())) {
                            let r = function t(e, i, n = 1) {
                                (0, eV.k)(n <= 4, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
                                let [r, s] = function(t) {
                                    let e = eM.exec(t);
                                    if (!e) return [, ];
                                    let [, i, n, r] = e;
                                    return [`--${null!=i?i:n}`, r]
                                }(e);
                                if (!r) return;
                                let o = window.getComputedStyle(i).getPropertyValue(r);
                                if (o) {
                                    let t = o.trim();
                                    return ek(t) ? parseFloat(t) : t
                                }
                                return td(s) ? t(s, i, n + 1) : s
                            }(n, e.current);
                            void 0 !== r && (t[i] = r), i === t.length - 1 && (this.finalKeyframe = n)
                        }
                    }
                    if (this.resolveNoneKeyframes(), !eR.has(i) || 2 !== t.length) return;
                    let [n, r] = t, s = eN(n), o = eN(r);
                    if (s !== o) {
                        if (eD(s) && eD(o))
                            for (let e = 0; e < t.length; e++) {
                                let i = t[e];
                                "string" == typeof i && (t[e] = parseFloat(i))
                            } else this.needsMeasurement = !0
                    }
                }
                resolveNoneKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        name: e
                    } = this, i = [];
                    for (let e = 0; e < t.length; e++) {
                        var n;
                        ("number" == typeof(n = t[e]) ? 0 === n : null === n || "none" === n || "0" === n || eC(n)) && i.push(e)
                    }
                    i.length && function(t, e, i) {
                        let n, r = 0;
                        for (; r < t.length && !n;) {
                            let e = t[r];
                            "string" == typeof e && !ia.has(e) && e9(e).values.length && (n = t[r]), r++
                        }
                        if (n && i)
                            for (let r of e) t[r] = io(i, n)
                    }(t, i, e)
                }
                measureInitialState() {
                    let {
                        element: t,
                        unresolvedKeyframes: e,
                        name: i
                    } = this;
                    if (!t.current) return;
                    "height" === i && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = eB[i](t.measureViewportBox(), window.getComputedStyle(t.current)), e[0] = this.measuredOrigin;
                    let n = e[e.length - 1];
                    void 0 !== n && t.getValue(i, n).jump(n, !1)
                }
                measureEndState() {
                    var t;
                    let {
                        element: e,
                        name: i,
                        unresolvedKeyframes: n
                    } = this;
                    if (!e.current) return;
                    let r = e.getValue(i);
                    r && r.jump(this.measuredOrigin, !1);
                    let s = n.length - 1,
                        o = n[s];
                    n[s] = eB[i](e.measureViewportBox(), window.getComputedStyle(e.current)), null !== o && void 0 === this.finalKeyframe && (this.finalKeyframe = o), (null === (t = this.removedTransforms) || void 0 === t ? void 0 : t.length) && this.removedTransforms.forEach(([t, i]) => {
                        e.getValue(t).set(i)
                    }), this.resolveNoneKeyframes()
                }
            }

            function iu(t) {
                let e;
                return () => (void 0 === e && (e = t()), e)
            }
            let ih = (t, e) => "zIndex" !== e && !!("number" == typeof t || Array.isArray(t) || "string" == typeof t && (e4.test(t) || "0" === t) && !t.startsWith("url("));
            class ic {
                constructor({
                    autoplay: t = !0,
                    delay: e = 0,
                    type: i = "keyframes",
                    repeat: n = 0,
                    repeatDelay: r = 0,
                    repeatType: s = "loop",
                    ...o
                }) {
                    this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = {
                        autoplay: t,
                        delay: e,
                        type: i,
                        repeat: n,
                        repeatDelay: r,
                        repeatType: s,
                        ...o
                    }, this.updateFinishedPromise()
                }
                get resolved() {
                    return this._resolved || this.hasAttemptedResolve || (eZ(), eH()), this._resolved
                }
                onKeyframesResolved(t, e) {
                    this.hasAttemptedResolve = !0;
                    let {
                        name: i,
                        type: n,
                        velocity: r,
                        delay: s,
                        onComplete: o,
                        onUpdate: a,
                        isGenerator: l
                    } = this.options;
                    if (!l && ! function(t, e, i, n) {
                            let r = t[0];
                            if (null === r) return !1;
                            if ("display" === e || "visibility" === e) return !0;
                            let s = t[t.length - 1],
                                o = ih(r, e),
                                a = ih(s, e);
                            return (0, eV.K)(o === a, `You are trying to animate ${e} from "${r}" to "${s}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${s} via the \`style\` property.`), !!o && !!a && (function(t) {
                                let e = t[0];
                                if (1 === t.length) return !0;
                                for (let i = 0; i < t.length; i++)
                                    if (t[i] !== e) return !0
                            }(t) || "spring" === i && n)
                        }(t, i, n, r)) {
                        if (eP.current || !s) {
                            null == a || a(eT(t, this.options, e)), null == o || o(), this.resolveFinishedPromise();
                            return
                        }
                        this.options.duration = 0
                    }
                    let u = this.initPlayback(t, e);
                    !1 !== u && (this._resolved = {
                        keyframes: t,
                        finalKeyframe: e,
                        ...u
                    }, this.onPostResolved())
                }
                onPostResolved() {}
                then(t, e) {
                    return this.currentFinishedPromise.then(t, e)
                }
                updateFinishedPromise() {
                    this.currentFinishedPromise = new Promise(t => {
                        this.resolveFinishedPromise = t
                    })
                }
            }

            function id(t, e, i) {
                var n, r;
                let s = Math.max(e - 5, 0);
                return n = i - t(s), (r = e - s) ? 1e3 / r * n : 0
            }

            function ip(t, e) {
                return t * Math.sqrt(1 - e * e)
            }
            let im = ["duration", "bounce"],
                iv = ["stiffness", "damping", "mass"];

            function ig(t, e) {
                return e.some(e => void 0 !== t[e])
            }

            function iy({
                keyframes: t,
                restDelta: e,
                restSpeed: i,
                ...n
            }) {
                let r;
                let s = t[0],
                    o = t[t.length - 1],
                    a = {
                        done: !1,
                        value: s
                    },
                    {
                        stiffness: l,
                        damping: u,
                        mass: h,
                        duration: c,
                        velocity: d,
                        isResolvedFromDuration: p
                    } = function(t) {
                        let e = {
                            velocity: 0,
                            stiffness: 100,
                            damping: 10,
                            mass: 1,
                            isResolvedFromDuration: !1,
                            ...t
                        };
                        if (!ig(t, iv) && ig(t, im)) {
                            let i = function({
                                duration: t = 800,
                                bounce: e = .25,
                                velocity: i = 0,
                                mass: n = 1
                            }) {
                                let r, s;
                                (0, eV.K)(t <= ef(10), "Spring duration must be 10 seconds or less");
                                let o = 1 - e;
                                o = z(.05, 1, o), t = z(.01, 10, em(t)), o < 1 ? (r = e => {
                                    let n = e * o,
                                        r = n * t;
                                    return .001 - (n - i) / ip(e, o) * Math.exp(-r)
                                }, s = e => {
                                    let n = e * o * t,
                                        s = Math.pow(o, 2) * Math.pow(e, 2) * t,
                                        a = ip(Math.pow(e, 2), o);
                                    return (n * i + i - s) * Math.exp(-n) * (-r(e) + .001 > 0 ? -1 : 1) / a
                                }) : (r = e => -.001 + Math.exp(-e * t) * ((e - i) * t + 1), s = e => t * t * (i - e) * Math.exp(-e * t));
                                let a = function(t, e, i) {
                                    let n = i;
                                    for (let i = 1; i < 12; i++) n -= t(n) / e(n);
                                    return n
                                }(r, s, 5 / t);
                                if (t = ef(t), isNaN(a)) return {
                                    stiffness: 100,
                                    damping: 10,
                                    duration: t
                                }; {
                                    let e = Math.pow(a, 2) * n;
                                    return {
                                        stiffness: e,
                                        damping: 2 * o * Math.sqrt(n * e),
                                        duration: t
                                    }
                                }
                            }(t);
                            (e = { ...e,
                                ...i,
                                mass: 1
                            }).isResolvedFromDuration = !0
                        }
                        return e
                    }({ ...n,
                        velocity: -em(n.velocity || 0)
                    }),
                    f = d || 0,
                    m = u / (2 * Math.sqrt(l * h)),
                    v = o - s,
                    g = em(Math.sqrt(l / h)),
                    y = 5 > Math.abs(v);
                if (i || (i = y ? .01 : 2), e || (e = y ? .005 : .5), m < 1) {
                    let t = ip(g, m);
                    r = e => o - Math.exp(-m * g * e) * ((f + m * g * v) / t * Math.sin(t * e) + v * Math.cos(t * e))
                } else if (1 === m) r = t => o - Math.exp(-g * t) * (v + (f + g * v) * t);
                else {
                    let t = g * Math.sqrt(m * m - 1);
                    r = e => {
                        let i = Math.exp(-m * g * e),
                            n = Math.min(t * e, 300);
                        return o - i * ((f + m * g * v) * Math.sinh(n) + t * v * Math.cosh(n)) / t
                    }
                }
                return {
                    calculatedDuration: p && c || null,
                    next: t => {
                        let n = r(t);
                        if (p) a.done = t >= c;
                        else {
                            let s = f;
                            0 !== t && (s = m < 1 ? id(r, t, n) : 0);
                            let l = Math.abs(s) <= i,
                                u = Math.abs(o - n) <= e;
                            a.done = l && u
                        }
                        return a.value = a.done ? o : n, a
                    }
                }
            }

            function ix({
                keyframes: t,
                velocity: e = 0,
                power: i = .8,
                timeConstant: n = 325,
                bounceDamping: r = 10,
                bounceStiffness: s = 500,
                modifyTarget: o,
                min: a,
                max: l,
                restDelta: u = .5,
                restSpeed: h
            }) {
                let c, d;
                let p = t[0],
                    f = {
                        done: !1,
                        value: p
                    },
                    m = t => void 0 !== a && t < a || void 0 !== l && t > l,
                    v = t => void 0 === a ? l : void 0 === l ? a : Math.abs(a - t) < Math.abs(l - t) ? a : l,
                    g = i * e,
                    y = p + g,
                    x = void 0 === o ? y : o(y);
                x !== y && (g = x - p);
                let b = t => -g * Math.exp(-t / n),
                    w = t => x + b(t),
                    P = t => {
                        let e = b(t),
                            i = w(t);
                        f.done = Math.abs(e) <= u, f.value = f.done ? x : i
                    },
                    S = t => {
                        m(f.value) && (c = t, d = iy({
                            keyframes: [f.value, v(f.value)],
                            velocity: id(w, t, f.value),
                            damping: r,
                            stiffness: s,
                            restDelta: u,
                            restSpeed: h
                        }))
                    };
                return S(0), {
                    calculatedDuration: null,
                    next: t => {
                        let e = !1;
                        return (d || void 0 !== c || (e = !0, P(t), S(t)), void 0 !== c && t >= c) ? d.next(t - c) : (e || P(t), f)
                    }
                }
            }
            let ib = (t, e, i) => (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t;

            function iw(t, e, i, n) {
                if (t === e && i === n) return tH.Z;
                let r = e => (function(t, e, i, n, r) {
                    let s, o;
                    let a = 0;
                    do(s = ib(o = e + (i - e) / 2, n, r) - t) > 0 ? i = o : e = o; while (Math.abs(s) > 1e-7 && ++a < 12);
                    return o
                })(e, 0, 1, t, i);
                return t => 0 === t || 1 === t ? t : ib(r(t), e, n)
            }
            let iP = iw(.42, 0, 1, 1),
                iS = iw(0, 0, .58, 1),
                iT = iw(.42, 0, .58, 1),
                iA = t => Array.isArray(t) && "number" != typeof t[0],
                iE = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
                iC = t => e => 1 - t(1 - e),
                iV = t => 1 - Math.sin(Math.acos(t)),
                ik = iC(iV),
                iM = iE(iV),
                iR = iw(.33, 1.53, .69, .99),
                iD = iC(iR),
                ij = iE(iD),
                iL = {
                    linear: tH.Z,
                    easeIn: iP,
                    easeInOut: iT,
                    easeOut: iS,
                    circIn: iV,
                    circInOut: iM,
                    circOut: ik,
                    backIn: iD,
                    backInOut: ij,
                    backOut: iR,
                    anticipate: t => (t *= 2) < 1 ? .5 * iD(t) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                },
                iF = t => {
                    if (Array.isArray(t)) {
                        (0, eV.k)(4 === t.length, "Cubic bezier arrays must contain four numerical values.");
                        let [e, i, n, r] = t;
                        return iw(e, i, n, r)
                    }
                    return "string" == typeof t ? ((0, eV.k)(void 0 !== iL[t], `Invalid easing type '${t}'`), iL[t]) : t
                },
                iO = (t, e, i) => {
                    let n = e - t;
                    return 0 === n ? 1 : (i - t) / n
                },
                iB = (t, e, i) => t + (e - t) * i;

            function iI(t, e, i) {
                return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? t + (e - t) * 6 * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            }

            function iU(t, e) {
                return i => i > 0 ? e : t
            }
            let iN = (t, e, i) => {
                    let n = t * t,
                        r = i * (e * e - n) + n;
                    return r < 0 ? 0 : Math.sqrt(r)
                },
                i$ = [eJ, eG, eQ],
                iW = t => i$.find(e => e.test(t));

            function iz(t) {
                let e = iW(t);
                if ((0, eV.K)(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e) return !1;
                let i = e.parse(t);
                return e === eQ && (i = function({
                    hue: t,
                    saturation: e,
                    lightness: i,
                    alpha: n
                }) {
                    t /= 360, i /= 100;
                    let r = 0,
                        s = 0,
                        o = 0;
                    if (e /= 100) {
                        let n = i < .5 ? i * (1 + e) : i + e - i * e,
                            a = 2 * i - n;
                        r = iI(a, n, t + 1 / 3), s = iI(a, n, t), o = iI(a, n, t - 1 / 3)
                    } else r = s = o = i;
                    return {
                        red: Math.round(255 * r),
                        green: Math.round(255 * s),
                        blue: Math.round(255 * o),
                        alpha: n
                    }
                }(i)), i
            }
            let iH = (t, e) => {
                    let i = iz(t),
                        n = iz(e);
                    if (!i || !n) return iU(t, e);
                    let r = { ...i
                    };
                    return t => (r.red = iN(i.red, n.red, t), r.green = iN(i.green, n.green, t), r.blue = iN(i.blue, n.blue, t), r.alpha = iB(i.alpha, n.alpha, t), eG.transform(r))
                },
                iZ = new Set(["none", "hidden"]);

            function iK(t, e) {
                return i => iB(t, e, i)
            }

            function iY(t) {
                return "number" == typeof t ? iK : "string" == typeof t ? td(t) ? iU : e0.test(t) ? iH : iq : Array.isArray(t) ? i_ : "object" == typeof t ? e0.test(t) ? iH : iX : iU
            }

            function i_(t, e) {
                let i = [...t],
                    n = i.length,
                    r = t.map((t, i) => iY(t)(t, e[i]));
                return t => {
                    for (let e = 0; e < n; e++) i[e] = r[e](t);
                    return i
                }
            }

            function iX(t, e) {
                let i = { ...t,
                        ...e
                    },
                    n = {};
                for (let r in i) void 0 !== t[r] && void 0 !== e[r] && (n[r] = iY(t[r])(t[r], e[r]));
                return t => {
                    for (let e in n) i[e] = n[e](t);
                    return i
                }
            }
            let iq = (t, e) => {
                let i = e4.createTransformer(e),
                    n = e9(t),
                    r = e9(e);
                return n.indexes.var.length === r.indexes.var.length && n.indexes.color.length === r.indexes.color.length && n.indexes.number.length >= r.indexes.number.length ? iZ.has(t) && !r.values.length || iZ.has(e) && !n.values.length ? iZ.has(t) ? i => i <= 0 ? t : e : i => i >= 1 ? e : t : t5(i_(function(t, e) {
                    var i;
                    let n = [],
                        r = {
                            color: 0,
                            var: 0,
                            number: 0
                        };
                    for (let s = 0; s < e.values.length; s++) {
                        let o = e.types[s],
                            a = t.indexes[o][r[o]],
                            l = null !== (i = t.values[a]) && void 0 !== i ? i : 0;
                        n[s] = l, r[o]++
                    }
                    return n
                }(n, r), r.values), i) : ((0, eV.K)(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), iU(t, e))
            };

            function iG(t, e, i) {
                return "number" == typeof t && "number" == typeof e && "number" == typeof i ? iB(t, e, i) : iY(t)(t, e)
            }

            function iJ({
                duration: t = 300,
                keyframes: e,
                times: i,
                ease: n = "easeInOut"
            }) {
                let r = iA(n) ? n.map(iF) : iF(n),
                    s = {
                        done: !1,
                        value: e[0]
                    },
                    o = function(t, e, {
                        clamp: i = !0,
                        ease: n,
                        mixer: r
                    } = {}) {
                        let s = t.length;
                        if ((0, eV.k)(s === e.length, "Both input and output ranges must be the same length"), 1 === s) return () => e[0];
                        if (2 === s && t[0] === t[1]) return () => e[1];
                        t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
                        let o = function(t, e, i) {
                                let n = [],
                                    r = i || iG,
                                    s = t.length - 1;
                                for (let i = 0; i < s; i++) {
                                    let s = r(t[i], t[i + 1]);
                                    e && (s = t5(Array.isArray(e) ? e[i] || tH.Z : e, s)), n.push(s)
                                }
                                return n
                            }(e, n, r),
                            a = o.length,
                            l = e => {
                                let i = 0;
                                if (a > 1)
                                    for (; i < t.length - 2 && !(e < t[i + 1]); i++);
                                let n = iO(t[i], t[i + 1], e);
                                return o[i](n)
                            };
                        return i ? e => l(z(t[0], t[s - 1], e)) : l
                    }((i && i.length === e.length ? i : function(t) {
                        let e = [0];
                        return function(t, e) {
                            let i = t[t.length - 1];
                            for (let n = 1; n <= e; n++) {
                                let r = iO(0, e, n);
                                t.push(iB(i, 1, r))
                            }
                        }(e, t.length - 1), e
                    }(e)).map(e => e * t), e, {
                        ease: Array.isArray(r) ? r : e.map(() => r || iT).splice(0, e.length - 1)
                    });
                return {
                    calculatedDuration: t,
                    next: e => (s.value = o(e), s.done = e >= t, s)
                }
            }
            let iQ = t => {
                    let e = ({
                        timestamp: e
                    }) => t(e);
                    return {
                        start: () => tZ.update(e, !0),
                        stop: () => tK(e),
                        now: () => tY.isProcessing ? tY.timestamp : eE.now()
                    }
                },
                i0 = {
                    decay: ix,
                    inertia: ix,
                    tween: iJ,
                    keyframes: iJ,
                    spring: iy
                },
                i1 = t => t / 100;
            class i2 extends ic {
                constructor({
                    KeyframeResolver: t = eK,
                    ...e
                }) {
                    super(e), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => {
                        if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return;
                        this.teardown();
                        let {
                            onStop: t
                        } = this.options;
                        t && t()
                    };
                    let {
                        name: i,
                        motionValue: n,
                        keyframes: r
                    } = this.options, s = (t, e) => this.onKeyframesResolved(t, e);
                    i && n && n.owner ? this.resolver = n.owner.resolveKeyframes(r, s, i, n) : this.resolver = new t(r, s, i, n), this.resolver.scheduleResolve()
                }
                initPlayback(t) {
                    let e, i;
                    let {
                        type: n = "keyframes",
                        repeat: r = 0,
                        repeatDelay: s = 0,
                        repeatType: o,
                        velocity: a = 0
                    } = this.options, l = i0[n] || iJ;
                    l !== iJ && "number" != typeof t[0] && (e = t5(i1, iG(t[0], t[1])), t = [0, 100]);
                    let u = l({ ...this.options,
                        keyframes: t
                    });
                    "mirror" === o && (i = l({ ...this.options,
                        keyframes: [...t].reverse(),
                        velocity: -a
                    })), null === u.calculatedDuration && (u.calculatedDuration = function(t) {
                        let e = 0,
                            i = t.next(e);
                        for (; !i.done && e < 2e4;) e += 50, i = t.next(e);
                        return e >= 2e4 ? 1 / 0 : e
                    }(u));
                    let {
                        calculatedDuration: h
                    } = u, c = h + s;
                    return {
                        generator: u,
                        mirroredGenerator: i,
                        mapPercentToKeyframes: e,
                        calculatedDuration: h,
                        resolvedDuration: c,
                        totalDuration: c * (r + 1) - s
                    }
                }
                onPostResolved() {
                    let {
                        autoplay: t = !0
                    } = this.options;
                    this.play(), "paused" !== this.pendingPlayState && t ? this.state = this.pendingPlayState : this.pause()
                }
                tick(t, e = !1) {
                    let {
                        resolved: i
                    } = this;
                    if (!i) {
                        let {
                            keyframes: t
                        } = this.options;
                        return {
                            done: !0,
                            value: t[t.length - 1]
                        }
                    }
                    let {
                        finalKeyframe: n,
                        generator: r,
                        mirroredGenerator: s,
                        mapPercentToKeyframes: o,
                        keyframes: a,
                        calculatedDuration: l,
                        totalDuration: u,
                        resolvedDuration: h
                    } = i;
                    if (null === this.startTime) return r.next(0);
                    let {
                        delay: c,
                        repeat: d,
                        repeatType: p,
                        repeatDelay: f,
                        onUpdate: m
                    } = this.options;
                    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), e ? this.currentTime = t : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
                    let v = this.currentTime - c * (this.speed >= 0 ? 1 : -1),
                        g = this.speed >= 0 ? v < 0 : v > u;
                    this.currentTime = Math.max(v, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = u);
                    let y = this.currentTime,
                        x = r;
                    if (d) {
                        let t = Math.min(this.currentTime, u) / h,
                            e = Math.floor(t),
                            i = t % 1;
                        !i && t >= 1 && (i = 1), 1 === i && e--, (e = Math.min(e, d + 1)) % 2 && ("reverse" === p ? (i = 1 - i, f && (i -= f / h)) : "mirror" === p && (x = s)), y = z(0, 1, i) * h
                    }
                    let b = g ? {
                        done: !1,
                        value: a[0]
                    } : x.next(y);
                    o && (b.value = o(b.value));
                    let {
                        done: w
                    } = b;
                    g || null === l || (w = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
                    let P = null === this.holdTime && ("finished" === this.state || "running" === this.state && w);
                    return P && void 0 !== n && (b.value = eT(a, this.options, n)), m && m(b.value), P && this.finish(), b
                }
                get duration() {
                    let {
                        resolved: t
                    } = this;
                    return t ? em(t.calculatedDuration) : 0
                }
                get time() {
                    return em(this.currentTime)
                }
                set time(t) {
                    t = ef(t), this.currentTime = t, null !== this.holdTime || 0 === this.speed ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed)
                }
                get speed() {
                    return this.playbackSpeed
                }
                set speed(t) {
                    let e = this.playbackSpeed !== t;
                    this.playbackSpeed = t, e && (this.time = em(this.currentTime))
                }
                play() {
                    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
                        this.pendingPlayState = "running";
                        return
                    }
                    if (this.isStopped) return;
                    let {
                        driver: t = iQ,
                        onPlay: e
                    } = this.options;
                    this.driver || (this.driver = t(t => this.tick(t))), e && e();
                    let i = this.driver.now();
                    null !== this.holdTime ? this.startTime = i - this.holdTime : this.startTime && "finished" !== this.state || (this.startTime = i), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
                }
                pause() {
                    var t;
                    if (!this._resolved) {
                        this.pendingPlayState = "paused";
                        return
                    }
                    this.state = "paused", this.holdTime = null !== (t = this.currentTime) && void 0 !== t ? t : 0
                }
                complete() {
                    "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
                }
                finish() {
                    this.teardown(), this.state = "finished";
                    let {
                        onComplete: t
                    } = this.options;
                    t && t()
                }
                cancel() {
                    null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
                }
                teardown() {
                    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
                }
                stopDriver() {
                    this.driver && (this.driver.stop(), this.driver = void 0)
                }
                sample(t) {
                    return this.startTime = 0, this.tick(t, !0)
                }
            }
            let i5 = t => Array.isArray(t) && "number" == typeof t[0],
                i9 = ([t, e, i, n]) => `cubic-bezier(${t}, ${e}, ${i}, ${n})`,
                i6 = {
                    linear: "linear",
                    ease: "ease",
                    easeIn: "ease-in",
                    easeOut: "ease-out",
                    easeInOut: "ease-in-out",
                    circIn: i9([0, .65, .55, 1]),
                    circOut: i9([.55, 0, 1, .45]),
                    backIn: i9([.31, .01, .66, -.59]),
                    backOut: i9([.33, 1.53, .69, .99])
                };

            function i3(t) {
                return i8(t) || i6.easeOut
            }

            function i8(t) {
                if (t) return i5(t) ? i9(t) : Array.isArray(t) ? t.map(i3) : i6[t]
            }
            let i4 = iu(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
            class i7 extends ic {
                constructor(t) {
                    super(t);
                    let {
                        name: e,
                        motionValue: i,
                        keyframes: n
                    } = this.options;
                    this.resolver = new il(n, (t, e) => this.onKeyframesResolved(t, e), e, i), this.resolver.scheduleResolve()
                }
                initPlayback(t, e) {
                    var i, n;
                    let {
                        duration: r = 300,
                        times: s,
                        ease: o,
                        type: a,
                        motionValue: l,
                        name: u
                    } = this.options;
                    if (!(null === (i = l.owner) || void 0 === i ? void 0 : i.current)) return !1;
                    if ("spring" === (n = this.options).type || ! function t(e) {
                            return !!(!e || "string" == typeof e && e in i6 || i5(e) || Array.isArray(e) && e.every(t))
                        }(n.ease)) {
                        let {
                            onComplete: e,
                            onUpdate: i,
                            motionValue: n,
                            ...l
                        } = this.options, u = function(t, e) {
                            let i = new i2({ ...e,
                                    keyframes: t,
                                    repeat: 0,
                                    delay: 0,
                                    isGenerator: !0
                                }),
                                n = {
                                    done: !1,
                                    value: t[0]
                                },
                                r = [],
                                s = 0;
                            for (; !n.done && s < 2e4;) r.push((n = i.sample(s)).value), s += 10;
                            return {
                                times: void 0,
                                keyframes: r,
                                duration: s - 10,
                                ease: "linear"
                            }
                        }(t, l);
                        1 === (t = u.keyframes).length && (t[1] = t[0]), r = u.duration, s = u.times, o = u.ease, a = "keyframes"
                    }
                    let h = function(t, e, i, {
                        delay: n = 0,
                        duration: r = 300,
                        repeat: s = 0,
                        repeatType: o = "loop",
                        ease: a,
                        times: l
                    } = {}) {
                        let u = {
                            [e]: i
                        };
                        l && (u.offset = l);
                        let h = i8(a);
                        return Array.isArray(h) && (u.easing = h), t.animate(u, {
                            delay: n,
                            duration: r,
                            easing: Array.isArray(h) ? "linear" : h,
                            fill: "both",
                            iterations: s + 1,
                            direction: "reverse" === o ? "alternate" : "normal"
                        })
                    }(l.owner.current, u, t, { ...this.options,
                        duration: r,
                        times: s,
                        ease: o
                    });
                    return h.startTime = eE.now(), this.pendingTimeline ? (h.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : h.onfinish = () => {
                        let {
                            onComplete: i
                        } = this.options;
                        l.set(eT(t, this.options, e)), i && i(), this.cancel(), this.resolveFinishedPromise()
                    }, {
                        animation: h,
                        duration: r,
                        times: s,
                        type: a,
                        ease: o,
                        keyframes: t
                    }
                }
                get duration() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 0;
                    let {
                        duration: e
                    } = t;
                    return em(e)
                }
                get time() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 0;
                    let {
                        animation: e
                    } = t;
                    return em(e.currentTime || 0)
                }
                set time(t) {
                    let {
                        resolved: e
                    } = this;
                    if (!e) return;
                    let {
                        animation: i
                    } = e;
                    i.currentTime = ef(t)
                }
                get speed() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 1;
                    let {
                        animation: e
                    } = t;
                    return e.playbackRate
                }
                set speed(t) {
                    let {
                        resolved: e
                    } = this;
                    if (!e) return;
                    let {
                        animation: i
                    } = e;
                    i.playbackRate = t
                }
                get state() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return "idle";
                    let {
                        animation: e
                    } = t;
                    return e.playState
                }
                attachTimeline(t) {
                    if (this._resolved) {
                        let {
                            resolved: e
                        } = this;
                        if (!e) return tH.Z;
                        let {
                            animation: i
                        } = e;
                        i.timeline = t, i.onfinish = null
                    } else this.pendingTimeline = t;
                    return tH.Z
                }
                play() {
                    if (this.isStopped) return;
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e
                    } = t;
                    "finished" === e.playState && this.updateFinishedPromise(), e.play()
                }
                pause() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e
                    } = t;
                    e.pause()
                }
                stop() {
                    if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return;
                    this.resolveFinishedPromise(), this.updateFinishedPromise();
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e,
                        keyframes: i,
                        duration: n,
                        type: r,
                        ease: s,
                        times: o
                    } = t;
                    if ("idle" === e.playState || "finished" === e.playState) return;
                    if (this.time) {
                        let {
                            motionValue: t,
                            onUpdate: e,
                            onComplete: a,
                            ...l
                        } = this.options, u = new i2({ ...l,
                            keyframes: i,
                            duration: n,
                            type: r,
                            ease: s,
                            times: o,
                            isGenerator: !0
                        }), h = ef(this.time);
                        t.setWithVelocity(u.sample(h - 10).value, u.sample(h).value, 10)
                    }
                    let {
                        onStop: a
                    } = this.options;
                    a && a(), this.cancel()
                }
                complete() {
                    let {
                        resolved: t
                    } = this;
                    t && t.animation.finish()
                }
                cancel() {
                    let {
                        resolved: t
                    } = this;
                    t && t.animation.cancel()
                }
                static supports(t) {
                    let {
                        motionValue: e,
                        name: i,
                        repeatDelay: n,
                        repeatType: r,
                        damping: s,
                        type: o
                    } = t;
                    return i4() && i && tI.has(i) && e && e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate && !n && "mirror" !== r && 0 !== s && "inertia" !== o
                }
            }
            let nt = iu(() => void 0 !== window.ScrollTimeline);
            class ne {
                constructor(t) {
                    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean)
                }
                then(t, e) {
                    return Promise.all(this.animations).then(t).catch(e)
                }
                getAll(t) {
                    return this.animations[0][t]
                }
                setAll(t, e) {
                    for (let i = 0; i < this.animations.length; i++) this.animations[i][t] = e
                }
                attachTimeline(t) {
                    let e = this.animations.map(e => {
                        if (!nt() || !e.attachTimeline) return e.pause(),
                            function(t, e) {
                                let i;
                                let n = () => {
                                    let {
                                        currentTime: n
                                    } = e, r = (null === n ? 0 : n.value) / 100;
                                    i !== r && t(r), i = r
                                };
                                return tZ.update(n, !0), () => tK(n)
                            }(t => {
                                e.time = e.duration * t
                            }, t);
                        e.attachTimeline(t)
                    });
                    return () => {
                        e.forEach((t, e) => {
                            t && t(), this.animations[e].stop()
                        })
                    }
                }
                get time() {
                    return this.getAll("time")
                }
                set time(t) {
                    this.setAll("time", t)
                }
                get speed() {
                    return this.getAll("speed")
                }
                set speed(t) {
                    this.setAll("speed", t)
                }
                get duration() {
                    let t = 0;
                    for (let e = 0; e < this.animations.length; e++) t = Math.max(t, this.animations[e].duration);
                    return t
                }
                runAll(t) {
                    this.animations.forEach(e => e[t]())
                }
                play() {
                    this.runAll("play")
                }
                pause() {
                    this.runAll("pause")
                }
                cancel() {
                    this.runAll("cancel")
                }
                complete() {
                    this.runAll("complete")
                }
            }
            let ni = (t, e, i, n = {}, r, s, o) => a => {
                let l = ew(n, t) || {},
                    u = l.delay || n.delay || 0,
                    {
                        elapsed: h = 0
                    } = n;
                h -= ef(u);
                let c = {
                    keyframes: Array.isArray(i) ? i : [null, i],
                    ease: "easeOut",
                    velocity: e.getVelocity(),
                    ...l,
                    delay: -h,
                    onUpdate: t => {
                        e.set(t), l.onUpdate && l.onUpdate(t)
                    },
                    onComplete: () => {
                        a(), l.onComplete && l.onComplete(), o && o()
                    },
                    onStop: o,
                    name: t,
                    motionValue: e,
                    element: s ? void 0 : r
                };
                ! function({
                    when: t,
                    delay: e,
                    delayChildren: i,
                    staggerChildren: n,
                    staggerDirection: r,
                    repeat: s,
                    repeatType: o,
                    repeatDelay: a,
                    from: l,
                    elapsed: u,
                    ...h
                }) {
                    return !!Object.keys(h).length
                }(l) && (c = { ...c,
                    ...eb(t, c)
                }), c.duration && (c.duration = ef(c.duration)), c.repeatDelay && (c.repeatDelay = ef(c.repeatDelay)), void 0 !== c.from && (c.keyframes[0] = c.from);
                let d = !1;
                if (!1 !== c.type && (0 !== c.duration || c.repeatDelay) || (c.duration = 0, 0 !== c.delay || (d = !0)), (eP.current || f.skipAnimations) && (d = !0, c.duration = 0, c.delay = 0), d && !s && void 0 !== e.get()) {
                    let t = eT(c.keyframes, l);
                    if (void 0 !== t) return tZ.update(() => {
                        c.onUpdate(t), c.onComplete()
                    }), new ne([])
                }
                return !s && i7.supports(c) ? new i7(c) : new i2(c)
            };
            class nn {
                constructor() {
                    this.subscriptions = []
                }
                add(t) {
                    return tN(this.subscriptions, t), () => t$(this.subscriptions, t)
                }
                notify(t, e, i) {
                    let n = this.subscriptions.length;
                    if (n) {
                        if (1 === n) this.subscriptions[0](t, e, i);
                        else
                            for (let r = 0; r < n; r++) {
                                let n = this.subscriptions[r];
                                n && n(t, e, i)
                            }
                    }
                }
                getSize() {
                    return this.subscriptions.length
                }
                clear() {
                    this.subscriptions.length = 0
                }
            }
            let nr = t => !isNaN(parseFloat(t)),
                ns = {
                    current: void 0
                };
            class no {
                constructor(t, e = {}) {
                    this.version = "11.3.21", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (t, e = !0) => {
                        let i = eE.now();
                        this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(t), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), e && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = e.owner
                }
                setCurrent(t) {
                    this.current = t, this.updatedAt = eE.now(), null === this.canTrackVelocity && void 0 !== t && (this.canTrackVelocity = nr(this.current))
                }
                setPrevFrameValue(t = this.current) {
                    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt
                }
                onChange(t) {
                    return this.on("change", t)
                }
                on(t, e) {
                    this.events[t] || (this.events[t] = new nn);
                    let i = this.events[t].add(e);
                    return "change" === t ? () => {
                        i(), tZ.read(() => {
                            this.events.change.getSize() || this.stop()
                        })
                    } : i
                }
                clearListeners() {
                    for (let t in this.events) this.events[t].clear()
                }
                attach(t, e) {
                    this.passiveEffect = t, this.stopPassiveEffect = e
                }
                set(t, e = !0) {
                    e && this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t, e)
                }
                setWithVelocity(t, e, i) {
                    this.set(e), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - i
                }
                jump(t, e = !0) {
                    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, e && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
                }
                get() {
                    return ns.current && ns.current.push(this), this.current
                }
                getPrevious() {
                    return this.prev
                }
                getVelocity() {
                    var t;
                    let e = eE.now();
                    if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0;
                    let i = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
                    return t = parseFloat(this.current) - parseFloat(this.prevFrameValue), i ? 1e3 / i * t : 0
                }
                start(t) {
                    return this.stop(), new Promise(e => {
                        this.hasAnimated = !0, this.animation = t(e), this.events.animationStart && this.events.animationStart.notify()
                    }).then(() => {
                        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
                    })
                }
                stop() {
                    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
                }
                isAnimating() {
                    return !!this.animation
                }
                clearAnimation() {
                    delete this.animation
                }
                destroy() {
                    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
                }
            }

            function na(t, e) {
                return new no(t, e)
            }

            function nl(t) {
                return t.getProps()[p]
            }
            class nu extends no {
                constructor() {
                    super(...arguments), this.output = [], this.counts = new Map
                }
                add(t) {
                    let e = tU(t);
                    if (!e) return;
                    let i = this.counts.get(e) || 0;
                    this.counts.set(e, i + 1), 0 === i && (this.output.push(e), this.update());
                    let n = !1;
                    return () => {
                        if (n) return;
                        n = !0;
                        let t = this.counts.get(e) - 1;
                        this.counts.set(e, t), 0 === t && (t$(this.output, e), this.update())
                    }
                }
                update() {
                    this.set(this.output.length ? this.output.join(", ") : "auto")
                }
            }

            function nh(t, e) {
                var i, n;
                if (!t.applyWillChange) return;
                let r = t.getValue("willChange");
                if (r || (null === (i = t.props.style) || void 0 === i ? void 0 : i.willChange) || (r = new nu("auto"), t.addValue("willChange", r)), $(n = r) && n.add) return r.add(e)
            }

            function nc(t, e, {
                delay: i = 0,
                transitionOverride: n,
                type: r
            } = {}) {
                var s;
                let {
                    transition: o = t.getDefaultTransition(),
                    transitionEnd: a,
                    ...l
                } = e;
                n && (o = n);
                let u = [],
                    h = r && t.animationState && t.animationState.getState()[r];
                for (let e in l) {
                    let n = t.getValue(e, null !== (s = t.latestValues[e]) && void 0 !== s ? s : null),
                        r = l[e];
                    if (void 0 === r || h && function({
                            protectedKeys: t,
                            needsAnimating: e
                        }, i) {
                            let n = t.hasOwnProperty(i) && !0 !== e[i];
                            return e[i] = !1, n
                        }(h, e)) continue;
                    let a = {
                            delay: i,
                            elapsed: 0,
                            ...ew(o || {}, e)
                        },
                        c = !1;
                    if (window.HandoffAppearAnimations) {
                        let i = nl(t);
                        if (i) {
                            let t = window.HandoffAppearAnimations(i, e, n, tZ);
                            null !== t && (a.elapsed = t, c = !0)
                        }
                    }
                    n.start(ni(e, n, r, t.shouldReduceMotion && U.has(e) ? {
                        type: !1
                    } : a, t, c, nh(t, e)));
                    let d = n.animation;
                    d && u.push(d)
                }
                return a && Promise.all(u).then(() => {
                    tZ.update(() => {
                        a && function(t, e) {
                            let {
                                transitionEnd: i = {},
                                transition: n = {},
                                ...r
                            } = ep(t, e) || {};
                            for (let e in r = { ...r,
                                    ...i
                                }) {
                                let i = tO(r[e]);
                                t.hasValue(e) ? t.getValue(e).set(i) : t.addValue(e, na(i))
                            }
                        }(t, a)
                    })
                }), u
            }

            function nd(t, e, i = {}) {
                var n;
                let r = ep(t, e, "exit" === i.type ? null === (n = t.presenceContext) || void 0 === n ? void 0 : n.custom : void 0),
                    {
                        transition: s = t.getDefaultTransition() || {}
                    } = r || {};
                i.transitionOverride && (s = i.transitionOverride);
                let o = r ? () => Promise.all(nc(t, r, i)) : () => Promise.resolve(),
                    a = t.variantChildren && t.variantChildren.size ? (n = 0) => {
                        let {
                            delayChildren: r = 0,
                            staggerChildren: o,
                            staggerDirection: a
                        } = s;
                        return function(t, e, i = 0, n = 0, r = 1, s) {
                            let o = [],
                                a = (t.variantChildren.size - 1) * n,
                                l = 1 === r ? (t = 0) => t * n : (t = 0) => a - t * n;
                            return Array.from(t.variantChildren).sort(np).forEach((t, n) => {
                                t.notify("AnimationStart", e), o.push(nd(t, e, { ...s,
                                    delay: i + l(n)
                                }).then(() => t.notify("AnimationComplete", e)))
                            }), Promise.all(o)
                        }(t, e, r + n, o, a, i)
                    } : () => Promise.resolve(),
                    {
                        when: l
                    } = s;
                if (!l) return Promise.all([o(), a(i.delay)]); {
                    let [t, e] = "beforeChildren" === l ? [o, a] : [a, o];
                    return t().then(() => e())
                }
            }

            function np(t, e) {
                return t.sortNodePosition(e)
            }
            let nf = [...A].reverse(),
                nm = A.length;

            function nv(t = !1) {
                return {
                    isActive: t,
                    protectedKeys: {},
                    needsAnimating: {},
                    prevResolvedValues: {}
                }
            }

            function ng() {
                return {
                    animate: nv(!0),
                    whileInView: nv(),
                    whileHover: nv(),
                    whileTap: nv(),
                    whileDrag: nv(),
                    whileFocus: nv(),
                    exit: nv()
                }
            }
            class ny extends t7 {
                constructor(t) {
                    super(t), t.animationState || (t.animationState = function(t) {
                        let e = e => Promise.all(e.map(({
                                animation: e,
                                options: i
                            }) => (function(t, e, i = {}) {
                                let n;
                                if (t.notify("AnimationStart", e), Array.isArray(e)) n = Promise.all(e.map(e => nd(t, e, i)));
                                else if ("string" == typeof e) n = nd(t, e, i);
                                else {
                                    let r = "function" == typeof e ? ep(t, e, i.custom) : e;
                                    n = Promise.all(nc(t, r, i))
                                }
                                return n.then(() => {
                                    t.notify("AnimationComplete", e)
                                })
                            })(t, e, i))),
                            i = ng(),
                            n = !0,
                            r = e => (i, n) => {
                                var r;
                                let s = ep(t, n, "exit" === e ? null === (r = t.presenceContext) || void 0 === r ? void 0 : r.custom : void 0);
                                if (s) {
                                    let {
                                        transition: t,
                                        transitionEnd: e,
                                        ...n
                                    } = s;
                                    i = { ...i,
                                        ...n,
                                        ...e
                                    }
                                }
                                return i
                            };

                        function s(s) {
                            let o = t.getProps(),
                                a = t.getVariantContext(!0) || {},
                                l = [],
                                u = new Set,
                                h = {},
                                c = 1 / 0;
                            for (let e = 0; e < nm; e++) {
                                var d;
                                let p = nf[e],
                                    f = i[p],
                                    m = void 0 !== o[p] ? o[p] : a[p],
                                    v = S(m),
                                    g = p === s ? f.isActive : null;
                                !1 === g && (c = e);
                                let y = m === a[p] && m !== o[p] && v;
                                if (y && n && t.manuallyAnimateOnMount && (y = !1), f.protectedKeys = { ...h
                                    }, !f.isActive && null === g || !m && !f.prevProp || T(m) || "boolean" == typeof m) continue;
                                let x = (d = f.prevProp, ("string" == typeof m ? m !== d : !!Array.isArray(m) && !ed(m, d)) || p === s && f.isActive && !y && v || e > c && v),
                                    b = !1,
                                    w = Array.isArray(m) ? m : [m],
                                    P = w.reduce(r(p), {});
                                !1 === g && (P = {});
                                let {
                                    prevResolvedValues: A = {}
                                } = f, E = { ...A,
                                    ...P
                                }, C = e => {
                                    x = !0, u.has(e) && (b = !0, u.delete(e)), f.needsAnimating[e] = !0;
                                    let i = t.getValue(e);
                                    i && (i.liveStyle = !1)
                                };
                                for (let t in E) {
                                    let e = P[t],
                                        i = A[t];
                                    if (!h.hasOwnProperty(t))(tL(e) && tL(i) ? ed(e, i) : e === i) ? void 0 !== e && u.has(t) ? C(t) : f.protectedKeys[t] = !0 : null != e ? C(t) : u.add(t)
                                }
                                f.prevProp = m, f.prevResolvedValues = P, f.isActive && (h = { ...h,
                                    ...P
                                }), n && t.blockInitialAnimation && (x = !1), x && (!y || b) && l.push(...w.map(t => ({
                                    animation: t,
                                    options: {
                                        type: p
                                    }
                                })))
                            }
                            if (u.size) {
                                let e = {};
                                u.forEach(i => {
                                    let n = t.getBaseTarget(i),
                                        r = t.getValue(i);
                                    r && (r.liveStyle = !0), e[i] = null != n ? n : null
                                }), l.push({
                                    animation: e
                                })
                            }
                            let p = !!l.length;
                            return n && (!1 === o.initial || o.initial === o.animate) && !t.manuallyAnimateOnMount && (p = !1), n = !1, p ? e(l) : Promise.resolve()
                        }
                        return {
                            animateChanges: s,
                            setActive: function(e, n) {
                                var r;
                                if (i[e].isActive === n) return Promise.resolve();
                                null === (r = t.variantChildren) || void 0 === r || r.forEach(t => {
                                    var i;
                                    return null === (i = t.animationState) || void 0 === i ? void 0 : i.setActive(e, n)
                                }), i[e].isActive = n;
                                let o = s(e);
                                for (let t in i) i[t].protectedKeys = {};
                                return o
                            },
                            setAnimateFunction: function(i) {
                                e = i(t)
                            },
                            getState: () => i,
                            reset: () => {
                                i = ng(), n = !0
                            }
                        }
                    }(t))
                }
                updateAnimationControlsSubscription() {
                    let {
                        animate: t
                    } = this.node.getProps();
                    T(t) && (this.unmountControls = t.subscribe(this.node))
                }
                mount() {
                    this.updateAnimationControlsSubscription()
                }
                update() {
                    let {
                        animate: t
                    } = this.node.getProps(), {
                        animate: e
                    } = this.node.prevProps || {};
                    t !== e && this.updateAnimationControlsSubscription()
                }
                unmount() {
                    var t;
                    this.node.animationState.reset(), null === (t = this.unmountControls) || void 0 === t || t.call(this)
                }
            }
            let nx = 0;
            class nb extends t7 {
                constructor() {
                    super(...arguments), this.id = nx++
                }
                update() {
                    if (!this.node.presenceContext) return;
                    let {
                        isPresent: t,
                        onExitComplete: e
                    } = this.node.presenceContext, {
                        isPresent: i
                    } = this.node.prevPresenceContext || {};
                    if (!this.node.animationState || t === i) return;
                    let n = this.node.animationState.setActive("exit", !t);
                    e && !t && n.then(() => e(this.id))
                }
                mount() {
                    let {
                        register: t
                    } = this.node.presenceContext || {};
                    t && (this.unmount = t(this.id))
                }
                unmount() {}
            }
            let nw = (t, e) => Math.abs(t - e);
            class nP {
                constructor(t, e, {
                    transformPagePoint: i,
                    contextWindow: n,
                    dragSnapToOrigin: r = !1
                } = {}) {
                    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
                            var t, e;
                            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                            let i = nA(this.lastMoveEventInfo, this.history),
                                n = null !== this.startEvent,
                                r = (t = i.offset, e = {
                                    x: 0,
                                    y: 0
                                }, Math.sqrt(nw(t.x, e.x) ** 2 + nw(t.y, e.y) ** 2) >= 3);
                            if (!n && !r) return;
                            let {
                                point: s
                            } = i, {
                                timestamp: o
                            } = tY;
                            this.history.push({ ...s,
                                timestamp: o
                            });
                            let {
                                onStart: a,
                                onMove: l
                            } = this.handlers;
                            n || (a && a(this.lastMoveEvent, i), this.startEvent = this.lastMoveEvent), l && l(this.lastMoveEvent, i)
                        }, this.handlePointerMove = (t, e) => {
                            this.lastMoveEvent = t, this.lastMoveEventInfo = nS(e, this.transformPagePoint), tZ.update(this.updatePoint, !0)
                        }, this.handlePointerUp = (t, e) => {
                            this.end();
                            let {
                                onEnd: i,
                                onSessionEnd: n,
                                resumeAnimation: r
                            } = this.handlers;
                            if (this.dragSnapToOrigin && r && r(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                            let s = nA("pointercancel" === t.type ? this.lastMoveEventInfo : nS(e, this.transformPagePoint), this.history);
                            this.startEvent && i && i(t, s), n && n(t, s)
                        }, !tJ(t)) return;
                    this.dragSnapToOrigin = r, this.handlers = e, this.transformPagePoint = i, this.contextWindow = n || window;
                    let s = nS(tQ(t), this.transformPagePoint),
                        {
                            point: o
                        } = s,
                        {
                            timestamp: a
                        } = tY;
                    this.history = [{ ...o,
                        timestamp: a
                    }];
                    let {
                        onSessionStart: l
                    } = e;
                    l && l(t, nA(s, this.history)), this.removeListeners = t5(t1(this.contextWindow, "pointermove", this.handlePointerMove), t1(this.contextWindow, "pointerup", this.handlePointerUp), t1(this.contextWindow, "pointercancel", this.handlePointerUp))
                }
                updateHandlers(t) {
                    this.handlers = t
                }
                end() {
                    this.removeListeners && this.removeListeners(), tK(this.updatePoint)
                }
            }

            function nS(t, e) {
                return e ? {
                    point: e(t.point)
                } : t
            }

            function nT(t, e) {
                return {
                    x: t.x - e.x,
                    y: t.y - e.y
                }
            }

            function nA({
                point: t
            }, e) {
                return {
                    point: t,
                    delta: nT(t, nE(e)),
                    offset: nT(t, e[0]),
                    velocity: function(t, e) {
                        if (t.length < 2) return {
                            x: 0,
                            y: 0
                        };
                        let i = t.length - 1,
                            n = null,
                            r = nE(t);
                        for (; i >= 0 && (n = t[i], !(r.timestamp - n.timestamp > ef(.1)));) i--;
                        if (!n) return {
                            x: 0,
                            y: 0
                        };
                        let s = em(r.timestamp - n.timestamp);
                        if (0 === s) return {
                            x: 0,
                            y: 0
                        };
                        let o = {
                            x: (r.x - n.x) / s,
                            y: (r.y - n.y) / s
                        };
                        return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
                    }(e, 0)
                }
            }

            function nE(t) {
                return t[t.length - 1]
            }

            function nC(t) {
                return t.max - t.min
            }

            function nV(t, e, i, n = .5) {
                t.origin = n, t.originPoint = iB(e.min, e.max, t.origin), t.scale = nC(i) / nC(e), t.translate = iB(i.min, i.max, t.origin) - t.originPoint, (t.scale >= .9999 && t.scale <= 1.0001 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= -.01 && t.translate <= .01 || isNaN(t.translate)) && (t.translate = 0)
            }

            function nk(t, e, i, n) {
                nV(t.x, e.x, i.x, n ? n.originX : void 0), nV(t.y, e.y, i.y, n ? n.originY : void 0)
            }

            function nM(t, e, i) {
                t.min = i.min + e.min, t.max = t.min + nC(e)
            }

            function nR(t, e, i) {
                t.min = e.min - i.min, t.max = t.min + nC(e)
            }

            function nD(t, e, i) {
                nR(t.x, e.x, i.x), nR(t.y, e.y, i.y)
            }

            function nj(t, e, i) {
                return {
                    min: void 0 !== e ? t.min + e : void 0,
                    max: void 0 !== i ? t.max + i - (t.max - t.min) : void 0
                }
            }

            function nL(t, e) {
                let i = e.min - t.min,
                    n = e.max - t.max;
                return e.max - e.min < t.max - t.min && ([i, n] = [n, i]), {
                    min: i,
                    max: n
                }
            }

            function nF(t, e, i) {
                return {
                    min: nO(t, e),
                    max: nO(t, i)
                }
            }

            function nO(t, e) {
                return "number" == typeof t ? t : t[e] || 0
            }
            let nB = () => ({
                    translate: 0,
                    scale: 1,
                    origin: 0,
                    originPoint: 0
                }),
                nI = () => ({
                    x: nB(),
                    y: nB()
                }),
                nU = () => ({
                    min: 0,
                    max: 0
                }),
                nN = () => ({
                    x: nU(),
                    y: nU()
                });

            function n$(t) {
                return [t("x"), t("y")]
            }

            function nW({
                top: t,
                left: e,
                right: i,
                bottom: n
            }) {
                return {
                    x: {
                        min: e,
                        max: i
                    },
                    y: {
                        min: t,
                        max: n
                    }
                }
            }

            function nz(t) {
                return void 0 === t || 1 === t
            }

            function nH({
                scale: t,
                scaleX: e,
                scaleY: i
            }) {
                return !nz(t) || !nz(e) || !nz(i)
            }

            function nZ(t) {
                return nH(t) || nK(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
            }

            function nK(t) {
                var e, i;
                return (e = t.x) && "0%" !== e || (i = t.y) && "0%" !== i
            }

            function nY(t, e, i, n, r) {
                return void 0 !== r && (t = n + r * (t - n)), n + i * (t - n) + e
            }

            function n_(t, e = 0, i = 1, n, r) {
                t.min = nY(t.min, e, i, n, r), t.max = nY(t.max, e, i, n, r)
            }

            function nX(t, {
                x: e,
                y: i
            }) {
                n_(t.x, e.translate, e.scale, e.originPoint), n_(t.y, i.translate, i.scale, i.originPoint)
            }

            function nq(t, e) {
                t.min = t.min + e, t.max = t.max + e
            }

            function nG(t, e, i, n, r = .5) {
                let s = iB(t.min, t.max, r);
                n_(t, e, i, s, n)
            }

            function nJ(t, e) {
                nG(t.x, e.x, e.scaleX, e.scale, e.originX), nG(t.y, e.y, e.scaleY, e.scale, e.originY)
            }

            function nQ(t, e) {
                return nW(function(t, e) {
                    if (!e) return t;
                    let i = e({
                            x: t.left,
                            y: t.top
                        }),
                        n = e({
                            x: t.right,
                            y: t.bottom
                        });
                    return {
                        top: i.y,
                        left: i.x,
                        bottom: n.y,
                        right: n.x
                    }
                }(t.getBoundingClientRect(), e))
            }
            let n0 = ({
                    current: t
                }) => t ? t.ownerDocument.defaultView : null,
                n1 = new WeakMap;
            class n2 {
                constructor(t) {
                    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
                        x: 0,
                        y: 0
                    }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = nN(), this.visualElement = t
                }
                start(t, {
                    snapToCursor: e = !1
                } = {}) {
                    let {
                        presenceContext: i
                    } = this.visualElement;
                    if (i && !1 === i.isPresent) return;
                    let {
                        dragSnapToOrigin: n
                    } = this.getProps();
                    this.panSession = new nP(t, {
                        onSessionStart: t => {
                            let {
                                dragSnapToOrigin: i
                            } = this.getProps();
                            i ? this.pauseAnimation() : this.stopAnimation(), e && this.snapToCursor(tQ(t, "page").point)
                        },
                        onStart: (t, e) => {
                            var i;
                            let {
                                drag: n,
                                dragPropagation: r,
                                onDragStart: s
                            } = this.getProps();
                            if (n && !r && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = t8(n), !this.openGlobalLock)) return;
                            this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), n$(t => {
                                let e = this.getAxisMotionValue(t).get() || 0;
                                if (tt.test(e)) {
                                    let {
                                        projection: i
                                    } = this.visualElement;
                                    if (i && i.layout) {
                                        let n = i.layout.layoutBox[t];
                                        if (n) {
                                            let t = nC(n);
                                            e = parseFloat(e) / 100 * t
                                        }
                                    }
                                }
                                this.originPoint[t] = e
                            }), s && tZ.postRender(() => s(t, e)), null === (i = this.removeWillChange) || void 0 === i || i.call(this), this.removeWillChange = nh(this.visualElement, "transform");
                            let {
                                animationState: o
                            } = this.visualElement;
                            o && o.setActive("whileDrag", !0)
                        },
                        onMove: (t, e) => {
                            let {
                                dragPropagation: i,
                                dragDirectionLock: n,
                                onDirectionLock: r,
                                onDrag: s
                            } = this.getProps();
                            if (!i && !this.openGlobalLock) return;
                            let {
                                offset: o
                            } = e;
                            if (n && null === this.currentDirection) {
                                this.currentDirection = function(t, e = 10) {
                                    let i = null;
                                    return Math.abs(t.y) > e ? i = "y" : Math.abs(t.x) > e && (i = "x"), i
                                }(o), null !== this.currentDirection && r && r(this.currentDirection);
                                return
                            }
                            this.updateAxis("x", e.point, o), this.updateAxis("y", e.point, o), this.visualElement.render(), s && s(t, e)
                        },
                        onSessionEnd: (t, e) => this.stop(t, e),
                        resumeAnimation: () => n$(t => {
                            var e;
                            return "paused" === this.getAnimationState(t) && (null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.play())
                        })
                    }, {
                        transformPagePoint: this.visualElement.getTransformPagePoint(),
                        dragSnapToOrigin: n,
                        contextWindow: n0(this.visualElement)
                    })
                }
                stop(t, e) {
                    var i;
                    null === (i = this.removeWillChange) || void 0 === i || i.call(this);
                    let n = this.isDragging;
                    if (this.cancel(), !n) return;
                    let {
                        velocity: r
                    } = e;
                    this.startAnimation(r);
                    let {
                        onDragEnd: s
                    } = this.getProps();
                    s && tZ.postRender(() => s(t, e))
                }
                cancel() {
                    this.isDragging = !1;
                    let {
                        projection: t,
                        animationState: e
                    } = this.visualElement;
                    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
                    let {
                        dragPropagation: i
                    } = this.getProps();
                    !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), e && e.setActive("whileDrag", !1)
                }
                updateAxis(t, e, i) {
                    let {
                        drag: n
                    } = this.getProps();
                    if (!i || !n5(t, n, this.currentDirection)) return;
                    let r = this.getAxisMotionValue(t),
                        s = this.originPoint[t] + i[t];
                    this.constraints && this.constraints[t] && (s = function(t, {
                        min: e,
                        max: i
                    }, n) {
                        return void 0 !== e && t < e ? t = n ? iB(e, t, n.min) : Math.max(t, e) : void 0 !== i && t > i && (t = n ? iB(i, t, n.max) : Math.min(t, i)), t
                    }(s, this.constraints[t], this.elastic[t])), r.set(s)
                }
                resolveConstraints() {
                    var t;
                    let {
                        dragConstraints: e,
                        dragElastic: i
                    } = this.getProps(), n = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (t = this.visualElement.projection) || void 0 === t ? void 0 : t.layout, r = this.constraints;
                    e && x(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = function(t, {
                        top: e,
                        left: i,
                        bottom: n,
                        right: r
                    }) {
                        return {
                            x: nj(t.x, i, r),
                            y: nj(t.y, e, n)
                        }
                    }(n.layoutBox, e) : this.constraints = !1, this.elastic = function(t = .35) {
                        return !1 === t ? t = 0 : !0 === t && (t = .35), {
                            x: nF(t, "left", "right"),
                            y: nF(t, "top", "bottom")
                        }
                    }(i), r !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && n$(t => {
                        !1 !== this.constraints && this.getAxisMotionValue(t) && (this.constraints[t] = function(t, e) {
                            let i = {};
                            return void 0 !== e.min && (i.min = e.min - t.min), void 0 !== e.max && (i.max = e.max - t.min), i
                        }(n.layoutBox[t], this.constraints[t]))
                    })
                }
                resolveRefConstraints() {
                    var t;
                    let {
                        dragConstraints: e,
                        onMeasureDragConstraints: i
                    } = this.getProps();
                    if (!e || !x(e)) return !1;
                    let n = e.current;
                    (0, eV.k)(null !== n, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
                    let {
                        projection: r
                    } = this.visualElement;
                    if (!r || !r.layout) return !1;
                    let s = function(t, e, i) {
                            let n = nQ(t, i),
                                {
                                    scroll: r
                                } = e;
                            return r && (nq(n.x, r.offset.x), nq(n.y, r.offset.y)), n
                        }(n, r.root, this.visualElement.getTransformPagePoint()),
                        o = {
                            x: nL((t = r.layout.layoutBox).x, s.x),
                            y: nL(t.y, s.y)
                        };
                    if (i) {
                        let t = i(function({
                            x: t,
                            y: e
                        }) {
                            return {
                                top: e.min,
                                right: t.max,
                                bottom: e.max,
                                left: t.min
                            }
                        }(o));
                        this.hasMutatedConstraints = !!t, t && (o = nW(t))
                    }
                    return o
                }
                startAnimation(t) {
                    let {
                        drag: e,
                        dragMomentum: i,
                        dragElastic: n,
                        dragTransition: r,
                        dragSnapToOrigin: s,
                        onDragTransitionEnd: o
                    } = this.getProps(), a = this.constraints || {};
                    return Promise.all(n$(o => {
                        if (!n5(o, e, this.currentDirection)) return;
                        let l = a && a[o] || {};
                        s && (l = {
                            min: 0,
                            max: 0
                        });
                        let u = {
                            type: "inertia",
                            velocity: i ? t[o] : 0,
                            bounceStiffness: n ? 200 : 1e6,
                            bounceDamping: n ? 40 : 1e7,
                            timeConstant: 750,
                            restDelta: 1,
                            restSpeed: 10,
                            ...r,
                            ...l
                        };
                        return this.startAxisValueAnimation(o, u)
                    })).then(o)
                }
                startAxisValueAnimation(t, e) {
                    let i = this.getAxisMotionValue(t);
                    return i.start(ni(t, i, 0, e, this.visualElement, !1, nh(this.visualElement, t)))
                }
                stopAnimation() {
                    n$(t => this.getAxisMotionValue(t).stop())
                }
                pauseAnimation() {
                    n$(t => {
                        var e;
                        return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.pause()
                    })
                }
                getAnimationState(t) {
                    var e;
                    return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.state
                }
                getAxisMotionValue(t) {
                    let e = `_drag${t.toUpperCase()}`,
                        i = this.visualElement.getProps();
                    return i[e] || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0)
                }
                snapToCursor(t) {
                    n$(e => {
                        let {
                            drag: i
                        } = this.getProps();
                        if (!n5(e, i, this.currentDirection)) return;
                        let {
                            projection: n
                        } = this.visualElement, r = this.getAxisMotionValue(e);
                        if (n && n.layout) {
                            let {
                                min: i,
                                max: s
                            } = n.layout.layoutBox[e];
                            r.set(t[e] - iB(i, s, .5))
                        }
                    })
                }
                scalePositionWithinConstraints() {
                    if (!this.visualElement.current) return;
                    let {
                        drag: t,
                        dragConstraints: e
                    } = this.getProps(), {
                        projection: i
                    } = this.visualElement;
                    if (!x(e) || !i || !this.constraints) return;
                    this.stopAnimation();
                    let n = {
                        x: 0,
                        y: 0
                    };
                    n$(t => {
                        let e = this.getAxisMotionValue(t);
                        if (e && !1 !== this.constraints) {
                            let i = e.get();
                            n[t] = function(t, e) {
                                let i = .5,
                                    n = nC(t),
                                    r = nC(e);
                                return r > n ? i = iO(e.min, e.max - n, t.min) : n > r && (i = iO(t.min, t.max - r, e.min)), z(0, 1, i)
                            }({
                                min: i,
                                max: i
                            }, this.constraints[t])
                        }
                    });
                    let {
                        transformTemplate: r
                    } = this.visualElement.getProps();
                    this.visualElement.current.style.transform = r ? r({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), n$(e => {
                        if (!n5(e, t, null)) return;
                        let i = this.getAxisMotionValue(e),
                            {
                                min: r,
                                max: s
                            } = this.constraints[e];
                        i.set(iB(r, s, n[e]))
                    })
                }
                addListeners() {
                    if (!this.visualElement.current) return;
                    n1.set(this.visualElement, this);
                    let t = t1(this.visualElement.current, "pointerdown", t => {
                            let {
                                drag: e,
                                dragListener: i = !0
                            } = this.getProps();
                            e && i && this.start(t)
                        }),
                        e = () => {
                            let {
                                dragConstraints: t
                            } = this.getProps();
                            x(t) && t.current && (this.constraints = this.resolveRefConstraints())
                        },
                        {
                            projection: i
                        } = this.visualElement,
                        n = i.addEventListener("measure", e);
                    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), tZ.read(e);
                    let r = tG(window, "resize", () => this.scalePositionWithinConstraints()),
                        s = i.addEventListener("didUpdate", ({
                            delta: t,
                            hasLayoutChanged: e
                        }) => {
                            this.isDragging && e && (n$(e => {
                                let i = this.getAxisMotionValue(e);
                                i && (this.originPoint[e] += t[e].translate, i.set(i.get() + t[e].translate))
                            }), this.visualElement.render())
                        });
                    return () => {
                        r(), t(), n(), s && s()
                    }
                }
                getProps() {
                    let t = this.visualElement.getProps(),
                        {
                            drag: e = !1,
                            dragDirectionLock: i = !1,
                            dragPropagation: n = !1,
                            dragConstraints: r = !1,
                            dragElastic: s = .35,
                            dragMomentum: o = !0
                        } = t;
                    return { ...t,
                        drag: e,
                        dragDirectionLock: i,
                        dragPropagation: n,
                        dragConstraints: r,
                        dragElastic: s,
                        dragMomentum: o
                    }
                }
            }

            function n5(t, e, i) {
                return (!0 === e || e === t) && (null === i || i === t)
            }
            class n9 extends t7 {
                constructor(t) {
                    super(t), this.removeGroupControls = tH.Z, this.removeListeners = tH.Z, this.controls = new n2(t)
                }
                mount() {
                    let {
                        dragControls: t
                    } = this.node.getProps();
                    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || tH.Z
                }
                unmount() {
                    this.removeGroupControls(), this.removeListeners()
                }
            }
            let n6 = t => (e, i) => {
                t && tZ.postRender(() => t(e, i))
            };
            class n3 extends t7 {
                constructor() {
                    super(...arguments), this.removePointerDownListener = tH.Z
                }
                onPointerDown(t) {
                    this.session = new nP(t, this.createPanHandlers(), {
                        transformPagePoint: this.node.getTransformPagePoint(),
                        contextWindow: n0(this.node)
                    })
                }
                createPanHandlers() {
                    let {
                        onPanSessionStart: t,
                        onPanStart: e,
                        onPan: i,
                        onPanEnd: n
                    } = this.node.getProps();
                    return {
                        onSessionStart: n6(t),
                        onStart: n6(e),
                        onMove: i,
                        onEnd: (t, e) => {
                            delete this.session, n && tZ.postRender(() => n(t, e))
                        }
                    }
                }
                mount() {
                    this.removePointerDownListener = t1(this.node.current, "pointerdown", t => this.onPointerDown(t))
                }
                update() {
                    this.session && this.session.updateHandlers(this.createPanHandlers())
                }
                unmount() {
                    this.removePointerDownListener(), this.session && this.session.end()
                }
            }
            let n8 = {
                hasAnimatedSinceResize: !0,
                hasEverUpdated: !1
            };

            function n4(t, e) {
                return e.max === e.min ? 0 : t / (e.max - e.min) * 100
            }
            let n7 = {
                correct: (t, e) => {
                    if (!e.target) return t;
                    if ("string" == typeof t) {
                        if (!te.test(t)) return t;
                        t = parseFloat(t)
                    }
                    let i = n4(t, e.target.x),
                        n = n4(t, e.target.y);
                    return `${i}% ${n}%`
                }
            };
            class rt extends o.Component {
                componentDidMount() {
                    let {
                        visualElement: t,
                        layoutGroup: e,
                        switchLayoutGroup: i,
                        layoutId: n
                    } = this.props, {
                        projection: r
                    } = t;
                    Object.assign(B, ri), r && (e.group && e.group.add(r), i && i.register && n && i.register(r), r.root.didUpdate(), r.addEventListener("animationComplete", () => {
                        this.safeToRemove()
                    }), r.setOptions({ ...r.options,
                        onExitComplete: () => this.safeToRemove()
                    })), n8.hasEverUpdated = !0
                }
                getSnapshotBeforeUpdate(t) {
                    let {
                        layoutDependency: e,
                        visualElement: i,
                        drag: n,
                        isPresent: r
                    } = this.props, s = i.projection;
                    return s && (s.isPresent = r, n || t.layoutDependency !== e || void 0 === e ? s.willUpdate() : this.safeToRemove(), t.isPresent === r || (r ? s.promote() : s.relegate() || tZ.postRender(() => {
                        let t = s.getStack();
                        t && t.members.length || this.safeToRemove()
                    }))), null
                }
                componentDidUpdate() {
                    let {
                        projection: t
                    } = this.props.visualElement;
                    t && (t.root.didUpdate(), g.postRender(() => {
                        !t.currentAnimation && t.isLead() && this.safeToRemove()
                    }))
                }
                componentWillUnmount() {
                    let {
                        visualElement: t,
                        layoutGroup: e,
                        switchLayoutGroup: i
                    } = this.props, {
                        projection: n
                    } = t;
                    n && (n.scheduleCheckAfterUnmount(), e && e.group && e.group.remove(n), i && i.deregister && i.deregister(n))
                }
                safeToRemove() {
                    let {
                        safeToRemove: t
                    } = this.props;
                    t && t()
                }
                render() {
                    return null
                }
            }

            function re(t) {
                let [e, i] = function() {
                    let t = (0, o.useContext)(u.O);
                    if (null === t) return [!0, null];
                    let {
                        isPresent: e,
                        onExitComplete: i,
                        register: n
                    } = t, r = (0, o.useId)();
                    (0, o.useEffect)(() => n(r), []);
                    let s = (0, o.useCallback)(() => i && i(r), [r, i]);
                    return !e && i ? [!1, s] : [!0]
                }(), n = (0, o.useContext)(j.p);
                return (0, s.jsx)(rt, { ...t,
                    layoutGroup: n,
                    switchLayoutGroup: (0, o.useContext)(b),
                    isPresent: e,
                    safeToRemove: i
                })
            }
            let ri = {
                    borderRadius: { ...n7,
                        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
                    },
                    borderTopLeftRadius: n7,
                    borderTopRightRadius: n7,
                    borderBottomLeftRadius: n7,
                    borderBottomRightRadius: n7,
                    boxShadow: {
                        correct: (t, {
                            treeScale: e,
                            projectionDelta: i
                        }) => {
                            let n = e4.parse(t);
                            if (n.length > 5) return t;
                            let r = e4.createTransformer(t),
                                s = "number" != typeof n[0] ? 1 : 0,
                                o = i.x.scale * e.x,
                                a = i.y.scale * e.y;
                            n[0 + s] /= o, n[1 + s] /= a;
                            let l = iB(o, a, .5);
                            return "number" == typeof n[2 + s] && (n[2 + s] /= l), "number" == typeof n[3 + s] && (n[3 + s] /= l), r(n)
                        }
                    }
                },
                rn = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
                rr = rn.length,
                rs = t => "string" == typeof t ? parseFloat(t) : t,
                ro = t => "number" == typeof t || te.test(t);

            function ra(t, e) {
                return void 0 !== t[e] ? t[e] : t.borderRadius
            }
            let rl = rh(0, .5, ik),
                ru = rh(.5, .95, tH.Z);

            function rh(t, e, i) {
                return n => n < t ? 0 : n > e ? 1 : i(iO(t, e, n))
            }

            function rc(t, e) {
                t.min = e.min, t.max = e.max
            }

            function rd(t, e) {
                rc(t.x, e.x), rc(t.y, e.y)
            }

            function rp(t, e) {
                t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin
            }

            function rf(t, e, i, n, r) {
                return t -= e, t = n + 1 / i * (t - n), void 0 !== r && (t = n + 1 / r * (t - n)), t
            }

            function rm(t, e, [i, n, r], s, o) {
                ! function(t, e = 0, i = 1, n = .5, r, s = t, o = t) {
                    if (tt.test(e) && (e = parseFloat(e), e = iB(o.min, o.max, e / 100) - o.min), "number" != typeof e) return;
                    let a = iB(s.min, s.max, n);
                    t === s && (a -= e), t.min = rf(t.min, e, i, a, r), t.max = rf(t.max, e, i, a, r)
                }(t, e[i], e[n], e[r], e.scale, s, o)
            }
            let rv = ["x", "scaleX", "originX"],
                rg = ["y", "scaleY", "originY"];

            function ry(t, e, i, n) {
                rm(t.x, e, rv, i ? i.x : void 0, n ? n.x : void 0), rm(t.y, e, rg, i ? i.y : void 0, n ? n.y : void 0)
            }

            function rx(t) {
                return 0 === t.translate && 1 === t.scale
            }

            function rb(t) {
                return rx(t.x) && rx(t.y)
            }

            function rw(t, e) {
                return t.min === e.min && t.max === e.max
            }

            function rP(t, e) {
                return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max)
            }

            function rS(t, e) {
                return rP(t.x, e.x) && rP(t.y, e.y)
            }

            function rT(t) {
                return nC(t.x) / nC(t.y)
            }

            function rA(t, e) {
                return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint
            }
            class rE {
                constructor() {
                    this.members = []
                }
                add(t) {
                    tN(this.members, t), t.scheduleRender()
                }
                remove(t) {
                    if (t$(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
                        let t = this.members[this.members.length - 1];
                        t && this.promote(t)
                    }
                }
                relegate(t) {
                    let e;
                    let i = this.members.findIndex(e => t === e);
                    if (0 === i) return !1;
                    for (let t = i; t >= 0; t--) {
                        let i = this.members[t];
                        if (!1 !== i.isPresent) {
                            e = i;
                            break
                        }
                    }
                    return !!e && (this.promote(e), !0)
                }
                promote(t, e) {
                    let i = this.lead;
                    if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
                        i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, e && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
                        let {
                            crossfade: n
                        } = t.options;
                        !1 === n && i.hide()
                    }
                }
                exitAnimationComplete() {
                    this.members.forEach(t => {
                        let {
                            options: e,
                            resumingFrom: i
                        } = t;
                        e.onExitComplete && e.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete()
                    })
                }
                scheduleRender() {
                    this.members.forEach(t => {
                        t.instance && t.scheduleRender(!1)
                    })
                }
                removeLeadSnapshot() {
                    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
                }
            }
            let rC = (t, e) => t.depth - e.depth;
            class rV {
                constructor() {
                    this.children = [], this.isDirty = !1
                }
                add(t) {
                    tN(this.children, t), this.isDirty = !0
                }
                remove(t) {
                    t$(this.children, t), this.isDirty = !0
                }
                forEach(t) {
                    this.isDirty && this.children.sort(rC), this.isDirty = !1, this.children.forEach(t)
                }
            }
            let rk = {
                    type: "projectionFrame",
                    totalNodes: 0,
                    resolvedTargetDeltas: 0,
                    recalculatedProjection: 0
                },
                rM = "undefined" != typeof window && void 0 !== window.MotionDebug,
                rR = ["", "X", "Y", "Z"],
                rD = {
                    visibility: "hidden"
                },
                rj = 0;

            function rL(t, e, i, n) {
                let {
                    latestValues: r
                } = e;
                r[t] && (i[t] = r[t], e.setStaticValue(t, 0), n && (n[t] = 0))
            }

            function rF({
                attachResizeListener: t,
                defaultParent: e,
                measureScroll: i,
                checkIsScrollRoot: n,
                resetTransform: r
            }) {
                return class {
                    constructor(t = {}, i = null == e ? void 0 : e()) {
                        this.id = rj++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                            x: 1,
                            y: 1
                        }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                            this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
                        }, this.updateProjection = () => {
                            this.projectionUpdateScheduled = !1, rM && (rk.totalNodes = rk.resolvedTargetDeltas = rk.recalculatedProjection = 0), this.nodes.forEach(rI), this.nodes.forEach(rZ), this.nodes.forEach(rK), this.nodes.forEach(rU), rM && window.MotionDebug.record(rk)
                        }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = t, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0;
                        for (let t = 0; t < this.path.length; t++) this.path[t].shouldResetTransform = !0;
                        this.root === this && (this.nodes = new rV)
                    }
                    addEventListener(t, e) {
                        return this.eventHandlers.has(t) || this.eventHandlers.set(t, new nn), this.eventHandlers.get(t).add(e)
                    }
                    notifyListeners(t, ...e) {
                        let i = this.eventHandlers.get(t);
                        i && i.notify(...e)
                    }
                    hasListeners(t) {
                        return this.eventHandlers.has(t)
                    }
                    mount(e, i = this.root.hasTreeAnimated) {
                        if (this.instance) return;
                        this.isSVG = e instanceof SVGElement && "svg" !== e.tagName, this.instance = e;
                        let {
                            layoutId: n,
                            layout: r,
                            visualElement: s
                        } = this.options;
                        if (s && !s.current && s.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), i && (r || n) && (this.isLayoutDirty = !0), t) {
                            let i;
                            let n = () => this.root.updateBlockedByResize = !1;
                            t(e, () => {
                                this.root.updateBlockedByResize = !0, i && i(), i = function(t, e) {
                                    let i = eE.now(),
                                        n = ({
                                            timestamp: e
                                        }) => {
                                            let r = e - i;
                                            r >= 250 && (tK(n), t(r - 250))
                                        };
                                    return tZ.read(n, !0), () => tK(n)
                                }(n, 0), n8.hasAnimatedSinceResize && (n8.hasAnimatedSinceResize = !1, this.nodes.forEach(rH))
                            })
                        }
                        n && this.root.registerSharedNode(n, this), !1 !== this.options.animate && s && (n || r) && this.addEventListener("didUpdate", ({
                            delta: t,
                            hasLayoutChanged: e,
                            hasRelativeTargetChanged: i,
                            layout: n
                        }) => {
                            if (this.isTreeAnimationBlocked()) {
                                this.target = void 0, this.relativeTarget = void 0;
                                return
                            }
                            let r = this.options.transition || s.getDefaultTransition() || rJ,
                                {
                                    onLayoutAnimationStart: o,
                                    onLayoutAnimationComplete: a
                                } = s.getProps(),
                                l = !this.targetLayout || !rS(this.targetLayout, n) || i,
                                u = !e && i;
                            if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || e && (l || !this.currentAnimation)) {
                                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, u);
                                let e = { ...ew(r, "layout"),
                                    onPlay: o,
                                    onComplete: a
                                };
                                (s.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e)
                            } else e || rH(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                            this.targetLayout = n
                        })
                    }
                    unmount() {
                        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
                        let t = this.getStack();
                        t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, tK(this.updateProjection)
                    }
                    blockUpdate() {
                        this.updateManuallyBlocked = !0
                    }
                    unblockUpdate() {
                        this.updateManuallyBlocked = !1
                    }
                    isUpdateBlocked() {
                        return this.updateManuallyBlocked || this.updateBlockedByResize
                    }
                    isTreeAnimationBlocked() {
                        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
                    }
                    startUpdate() {
                        !this.isUpdateBlocked() && (this.isUpdating = !0, this.nodes && this.nodes.forEach(rY), this.animationId++)
                    }
                    getTransformTemplate() {
                        let {
                            visualElement: t
                        } = this.options;
                        return t && t.getProps().transformTemplate
                    }
                    willUpdate(t = !0) {
                        if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                            this.options.onExitComplete && this.options.onExitComplete();
                            return
                        }
                        if (window.HandoffCancelAllAnimations && function t(e) {
                                if (e.hasCheckedOptimisedAppear = !0, e.root === e) return !1;
                                let {
                                    visualElement: i
                                } = e.options;
                                return !!i && (!!nl(i) || !!e.parent && !e.parent.hasCheckedOptimisedAppear && t(e.parent))
                            }(this) && window.HandoffCancelAllAnimations(), this.root.isUpdating || this.root.startUpdate(), this.isLayoutDirty) return;
                        this.isLayoutDirty = !0;
                        for (let t = 0; t < this.path.length; t++) {
                            let e = this.path[t];
                            e.shouldResetTransform = !0, e.updateScroll("snapshot"), e.options.layoutRoot && e.willUpdate(!1)
                        }
                        let {
                            layoutId: e,
                            layout: i
                        } = this.options;
                        if (void 0 === e && !i) return;
                        let n = this.getTransformTemplate();
                        this.prevTransformTemplateValue = n ? n(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate")
                    }
                    update() {
                        if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                            this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(r$);
                            return
                        }
                        this.isUpdating || this.nodes.forEach(rW), this.isUpdating = !1, this.nodes.forEach(rz), this.nodes.forEach(rO), this.nodes.forEach(rB), this.clearAllSnapshots();
                        let t = eE.now();
                        tY.delta = z(0, 1e3 / 60, t - tY.timestamp), tY.timestamp = t, tY.isProcessing = !0, t_.update.process(tY), t_.preRender.process(tY), t_.render.process(tY), tY.isProcessing = !1
                    }
                    didUpdate() {
                        this.updateScheduled || (this.updateScheduled = !0, g.read(this.scheduleUpdate))
                    }
                    clearAllSnapshots() {
                        this.nodes.forEach(rN), this.sharedNodes.forEach(r_)
                    }
                    scheduleUpdateProjection() {
                        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, tZ.preRender(this.updateProjection, !1, !0))
                    }
                    scheduleCheckAfterUnmount() {
                        tZ.postRender(() => {
                            this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                        })
                    }
                    updateSnapshot() {
                        !this.snapshot && this.instance && (this.snapshot = this.measure())
                    }
                    updateLayout() {
                        if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
                        if (this.resumeFrom && !this.resumeFrom.instance)
                            for (let t = 0; t < this.path.length; t++) this.path[t].updateScroll();
                        let t = this.layout;
                        this.layout = this.measure(!1), this.layoutCorrected = nN(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
                        let {
                            visualElement: e
                        } = this.options;
                        e && e.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0)
                    }
                    updateScroll(t = "measure") {
                        let e = !!(this.options.layoutScroll && this.instance);
                        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e) {
                            let e = n(this.instance);
                            this.scroll = {
                                animationId: this.root.animationId,
                                phase: t,
                                isRoot: e,
                                offset: i(this.instance),
                                wasRoot: this.scroll ? this.scroll.isRoot : e
                            }
                        }
                    }
                    resetTransform() {
                        if (!r) return;
                        let t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                            e = this.projectionDelta && !rb(this.projectionDelta),
                            i = this.getTransformTemplate(),
                            n = i ? i(this.latestValues, "") : void 0,
                            s = n !== this.prevTransformTemplateValue;
                        t && (e || nZ(this.latestValues) || s) && (r(this.instance, n), this.shouldResetTransform = !1, this.scheduleRender())
                    }
                    measure(t = !0) {
                        var e;
                        let i = this.measurePageBox(),
                            n = this.removeElementScroll(i);
                        return t && (n = this.removeTransform(n)), r1((e = n).x), r1(e.y), {
                            animationId: this.root.animationId,
                            measuredBox: i,
                            layoutBox: n,
                            latestValues: {},
                            source: this.id
                        }
                    }
                    measurePageBox() {
                        var t;
                        let {
                            visualElement: e
                        } = this.options;
                        if (!e) return nN();
                        let i = e.measureViewportBox();
                        if (!((null === (t = this.scroll) || void 0 === t ? void 0 : t.wasRoot) || this.path.some(r5))) {
                            let {
                                scroll: t
                            } = this.root;
                            t && (nq(i.x, t.offset.x), nq(i.y, t.offset.y))
                        }
                        return i
                    }
                    removeElementScroll(t) {
                        var e;
                        let i = nN();
                        if (rd(i, t), null === (e = this.scroll) || void 0 === e ? void 0 : e.wasRoot) return i;
                        for (let e = 0; e < this.path.length; e++) {
                            let n = this.path[e],
                                {
                                    scroll: r,
                                    options: s
                                } = n;
                            n !== this.root && r && s.layoutScroll && (r.wasRoot && rd(i, t), nq(i.x, r.offset.x), nq(i.y, r.offset.y))
                        }
                        return i
                    }
                    applyTransform(t, e = !1) {
                        let i = nN();
                        rd(i, t);
                        for (let t = 0; t < this.path.length; t++) {
                            let n = this.path[t];
                            !e && n.options.layoutScroll && n.scroll && n !== n.root && nJ(i, {
                                x: -n.scroll.offset.x,
                                y: -n.scroll.offset.y
                            }), nZ(n.latestValues) && nJ(i, n.latestValues)
                        }
                        return nZ(this.latestValues) && nJ(i, this.latestValues), i
                    }
                    removeTransform(t) {
                        let e = nN();
                        rd(e, t);
                        for (let t = 0; t < this.path.length; t++) {
                            let i = this.path[t];
                            if (!i.instance || !nZ(i.latestValues)) continue;
                            nH(i.latestValues) && i.updateSnapshot();
                            let n = nN();
                            rd(n, i.measurePageBox()), ry(e, i.latestValues, i.snapshot ? i.snapshot.layoutBox : void 0, n)
                        }
                        return nZ(this.latestValues) && ry(e, this.latestValues), e
                    }
                    setTargetDelta(t) {
                        this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
                    }
                    setOptions(t) {
                        this.options = { ...this.options,
                            ...t,
                            crossfade: void 0 === t.crossfade || t.crossfade
                        }
                    }
                    clearMeasurements() {
                        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
                    }
                    forceRelativeParentToResolveTarget() {
                        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== tY.timestamp && this.relativeParent.resolveTargetDelta(!0)
                    }
                    resolveTargetDelta(t = !1) {
                        var e, i, n, r;
                        let s = this.getLead();
                        this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = s.isSharedProjectionDirty);
                        let o = !!this.resumingFrom || this !== s;
                        if (!(t || o && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
                        let {
                            layout: a,
                            layoutId: l
                        } = this.options;
                        if (this.layout && (a || l)) {
                            if (this.resolvedRelativeTargetAt = tY.timestamp, !this.targetDelta && !this.relativeTarget) {
                                let t = this.getClosestProjectingParent();
                                t && t.layout && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = nN(), this.relativeTargetOrigin = nN(), nD(this.relativeTargetOrigin, this.layout.layoutBox, t.layout.layoutBox), rd(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                            }
                            if (this.relativeTarget || this.targetDelta) {
                                if ((this.target || (this.target = nN(), this.targetWithTransforms = nN()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) ? (this.forceRelativeParentToResolveTarget(), i = this.target, n = this.relativeTarget, r = this.relativeParent.target, nM(i.x, n.x, r.x), nM(i.y, n.y, r.y)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : rd(this.target, this.layout.layoutBox), nX(this.target, this.targetDelta)) : rd(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                                    this.attemptToResolveRelativeTarget = !1;
                                    let t = this.getClosestProjectingParent();
                                    t && !!t.resumingFrom == !!this.resumingFrom && !t.options.layoutScroll && t.target && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = nN(), this.relativeTargetOrigin = nN(), nD(this.relativeTargetOrigin, this.target, t.target), rd(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                                }
                                rM && rk.resolvedTargetDeltas++
                            }
                        }
                    }
                    getClosestProjectingParent() {
                        return !this.parent || nH(this.parent.latestValues) || nK(this.parent.latestValues) ? void 0 : this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
                    }
                    isProjecting() {
                        return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
                    }
                    calcProjection() {
                        var t;
                        let e = this.getLead(),
                            i = !!this.resumingFrom || this !== e,
                            n = !0;
                        if ((this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty)) && (n = !1), i && (this.isSharedProjectionDirty || this.isTransformDirty) && (n = !1), this.resolvedRelativeTargetAt === tY.timestamp && (n = !1), n) return;
                        let {
                            layout: r,
                            layoutId: s
                        } = this.options;
                        if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(r || s)) return;
                        rd(this.layoutCorrected, this.layout.layoutBox);
                        let o = this.treeScale.x,
                            a = this.treeScale.y;
                        ! function(t, e, i, n = !1) {
                            let r, s;
                            let o = i.length;
                            if (o) {
                                e.x = e.y = 1;
                                for (let a = 0; a < o; a++) {
                                    s = (r = i[a]).projectionDelta;
                                    let {
                                        visualElement: o
                                    } = r.options;
                                    (!o || !o.props.style || "contents" !== o.props.style.display) && (n && r.options.layoutScroll && r.scroll && r !== r.root && nJ(t, {
                                        x: -r.scroll.offset.x,
                                        y: -r.scroll.offset.y
                                    }), s && (e.x *= s.x.scale, e.y *= s.y.scale, nX(t, s)), n && nZ(r.latestValues) && nJ(t, r.latestValues))
                                }
                                e.x < 1.0000000000001 && e.x > .999999999999 && (e.x = 1), e.y < 1.0000000000001 && e.y > .999999999999 && (e.y = 1)
                            }
                        }(this.layoutCorrected, this.treeScale, this.path, i), e.layout && !e.target && (1 !== this.treeScale.x || 1 !== this.treeScale.y) && (e.target = e.layout.layoutBox, e.targetWithTransforms = nN());
                        let {
                            target: l
                        } = e;
                        if (!l) {
                            this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                            return
                        }
                        this.projectionDelta && this.prevProjectionDelta ? (rp(this.prevProjectionDelta.x, this.projectionDelta.x), rp(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), nk(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.treeScale.x === o && this.treeScale.y === a && rA(this.projectionDelta.x, this.prevProjectionDelta.x) && rA(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l)), rM && rk.recalculatedProjection++
                    }
                    hide() {
                        this.isVisible = !1
                    }
                    show() {
                        this.isVisible = !0
                    }
                    scheduleRender(t = !0) {
                        var e;
                        if (null === (e = this.options.visualElement) || void 0 === e || e.scheduleRender(), t) {
                            let t = this.getStack();
                            t && t.scheduleRender()
                        }
                        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
                    }
                    createProjectionDeltas() {
                        this.prevProjectionDelta = nI(), this.projectionDelta = nI(), this.projectionDeltaWithTransform = nI()
                    }
                    setAnimationOrigin(t, e = !1) {
                        let i;
                        let n = this.snapshot,
                            r = n ? n.latestValues : {},
                            s = { ...this.latestValues
                            },
                            o = nI();
                        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;
                        let a = nN(),
                            l = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0),
                            u = this.getStack(),
                            h = !u || u.members.length <= 1,
                            c = !!(l && !h && !0 === this.options.crossfade && !this.path.some(rG));
                        this.animationProgress = 0, this.mixTargetDelta = e => {
                            let n = e / 1e3;
                            if (rX(o.x, t.x, n), rX(o.y, t.y, n), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
                                var u, d, p, f;
                                nD(a, this.layout.layoutBox, this.relativeParent.layout.layoutBox), p = this.relativeTarget, f = this.relativeTargetOrigin, rq(p.x, f.x, a.x, n), rq(p.y, f.y, a.y, n), i && (u = this.relativeTarget, d = i, rw(u.x, d.x) && rw(u.y, d.y)) && (this.isProjectionDirty = !1), i || (i = nN()), rd(i, this.relativeTarget)
                            }
                            l && (this.animationValues = s, function(t, e, i, n, r, s) {
                                r ? (t.opacity = iB(0, void 0 !== i.opacity ? i.opacity : 1, rl(n)), t.opacityExit = iB(void 0 !== e.opacity ? e.opacity : 1, 0, ru(n))) : s && (t.opacity = iB(void 0 !== e.opacity ? e.opacity : 1, void 0 !== i.opacity ? i.opacity : 1, n));
                                for (let r = 0; r < rr; r++) {
                                    let s = `border${rn[r]}Radius`,
                                        o = ra(e, s),
                                        a = ra(i, s);
                                    (void 0 !== o || void 0 !== a) && (o || (o = 0), a || (a = 0), 0 === o || 0 === a || ro(o) === ro(a) ? (t[s] = Math.max(iB(rs(o), rs(a), n), 0), (tt.test(a) || tt.test(o)) && (t[s] += "%")) : t[s] = a)
                                }(e.rotate || i.rotate) && (t.rotate = iB(e.rotate || 0, i.rotate || 0, n))
                            }(s, r, this.latestValues, n, c, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n
                        }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
                    }
                    startAnimation(t) {
                        this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (tK(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = tZ.update(() => {
                            n8.hasAnimatedSinceResize = !0, this.currentAnimation = function(t, e, i) {
                                let n = $(0) ? 0 : na(0);
                                return n.start(ni("", n, 1e3, i)), n.animation
                            }(0, 0, { ...t,
                                onUpdate: e => {
                                    this.mixTargetDelta(e), t.onUpdate && t.onUpdate(e)
                                },
                                onComplete: () => {
                                    t.onComplete && t.onComplete(), this.completeAnimation()
                                }
                            }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
                        })
                    }
                    completeAnimation() {
                        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
                        let t = this.getStack();
                        t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
                    }
                    finishAnimation() {
                        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation()
                    }
                    applyTransformsToTarget() {
                        let t = this.getLead(),
                            {
                                targetWithTransforms: e,
                                target: i,
                                layout: n,
                                latestValues: r
                            } = t;
                        if (e && i && n) {
                            if (this !== t && this.layout && n && r2(this.options.animationType, this.layout.layoutBox, n.layoutBox)) {
                                i = this.target || nN();
                                let e = nC(this.layout.layoutBox.x);
                                i.x.min = t.target.x.min, i.x.max = i.x.min + e;
                                let n = nC(this.layout.layoutBox.y);
                                i.y.min = t.target.y.min, i.y.max = i.y.min + n
                            }
                            rd(e, i), nJ(e, r), nk(this.projectionDeltaWithTransform, this.layoutCorrected, e, r)
                        }
                    }
                    registerSharedNode(t, e) {
                        this.sharedNodes.has(t) || this.sharedNodes.set(t, new rE), this.sharedNodes.get(t).add(e);
                        let i = e.options.initialPromotionConfig;
                        e.promote({
                            transition: i ? i.transition : void 0,
                            preserveFollowOpacity: i && i.shouldPreserveFollowOpacity ? i.shouldPreserveFollowOpacity(e) : void 0
                        })
                    }
                    isLead() {
                        let t = this.getStack();
                        return !t || t.lead === this
                    }
                    getLead() {
                        var t;
                        let {
                            layoutId: e
                        } = this.options;
                        return e && (null === (t = this.getStack()) || void 0 === t ? void 0 : t.lead) || this
                    }
                    getPrevLead() {
                        var t;
                        let {
                            layoutId: e
                        } = this.options;
                        return e ? null === (t = this.getStack()) || void 0 === t ? void 0 : t.prevLead : void 0
                    }
                    getStack() {
                        let {
                            layoutId: t
                        } = this.options;
                        if (t) return this.root.sharedNodes.get(t)
                    }
                    promote({
                        needsReset: t,
                        transition: e,
                        preserveFollowOpacity: i
                    } = {}) {
                        let n = this.getStack();
                        n && n.promote(this, i), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({
                            transition: e
                        })
                    }
                    relegate() {
                        let t = this.getStack();
                        return !!t && t.relegate(this)
                    }
                    resetSkewAndRotation() {
                        let {
                            visualElement: t
                        } = this.options;
                        if (!t) return;
                        let e = !1,
                            {
                                latestValues: i
                            } = t;
                        if ((i.z || i.rotate || i.rotateX || i.rotateY || i.rotateZ || i.skewX || i.skewY) && (e = !0), !e) return;
                        let n = {};
                        i.z && rL("z", t, n, this.animationValues);
                        for (let e = 0; e < rR.length; e++) rL(`rotate${rR[e]}`, t, n, this.animationValues), rL(`skew${rR[e]}`, t, n, this.animationValues);
                        for (let e in t.render(), n) t.setStaticValue(e, n[e]), this.animationValues && (this.animationValues[e] = n[e]);
                        t.scheduleRender()
                    }
                    getProjectionStyles(t) {
                        var e, i;
                        if (!this.instance || this.isSVG) return;
                        if (!this.isVisible) return rD;
                        let n = {
                                visibility: ""
                            },
                            r = this.getTransformTemplate();
                        if (this.needsReset) return this.needsReset = !1, n.opacity = "", n.pointerEvents = tB(null == t ? void 0 : t.pointerEvents) || "", n.transform = r ? r(this.latestValues, "") : "none", n;
                        let s = this.getLead();
                        if (!this.projectionDelta || !this.layout || !s.target) {
                            let e = {};
                            return this.options.layoutId && (e.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e.pointerEvents = tB(null == t ? void 0 : t.pointerEvents) || ""), this.hasProjected && !nZ(this.latestValues) && (e.transform = r ? r({}, "") : "none", this.hasProjected = !1), e
                        }
                        let o = s.animationValues || s.latestValues;
                        this.applyTransformsToTarget(), n.transform = function(t, e, i) {
                            let n = "",
                                r = t.x.translate / e.x,
                                s = t.y.translate / e.y,
                                o = (null == i ? void 0 : i.z) || 0;
                            if ((r || s || o) && (n = `translate3d(${r}px, ${s}px, ${o}px) `), (1 !== e.x || 1 !== e.y) && (n += `scale(${1/e.x}, ${1/e.y}) `), i) {
                                let {
                                    transformPerspective: t,
                                    rotate: e,
                                    rotateX: r,
                                    rotateY: s,
                                    skewX: o,
                                    skewY: a
                                } = i;
                                t && (n = `perspective(${t}px) ${n}`), e && (n += `rotate(${e}deg) `), r && (n += `rotateX(${r}deg) `), s && (n += `rotateY(${s}deg) `), o && (n += `skewX(${o}deg) `), a && (n += `skewY(${a}deg) `)
                            }
                            let a = t.x.scale * e.x,
                                l = t.y.scale * e.y;
                            return (1 !== a || 1 !== l) && (n += `scale(${a}, ${l})`), n || "none"
                        }(this.projectionDeltaWithTransform, this.treeScale, o), r && (n.transform = r(o, n.transform));
                        let {
                            x: a,
                            y: l
                        } = this.projectionDelta;
                        for (let t in n.transformOrigin = `${100*a.origin}% ${100*l.origin}% 0`, s.animationValues ? n.opacity = s === this ? null !== (i = null !== (e = o.opacity) && void 0 !== e ? e : this.latestValues.opacity) && void 0 !== i ? i : 1 : this.preserveOpacity ? this.latestValues.opacity : o.opacityExit : n.opacity = s === this ? void 0 !== o.opacity ? o.opacity : "" : void 0 !== o.opacityExit ? o.opacityExit : 0, B) {
                            if (void 0 === o[t]) continue;
                            let {
                                correct: e,
                                applyTo: i
                            } = B[t], r = "none" === n.transform ? o[t] : e(o[t], s);
                            if (i) {
                                let t = i.length;
                                for (let e = 0; e < t; e++) n[i[e]] = r
                            } else n[t] = r
                        }
                        return this.options.layoutId && (n.pointerEvents = s === this ? tB(null == t ? void 0 : t.pointerEvents) || "" : "none"), n
                    }
                    clearSnapshot() {
                        this.resumeFrom = this.snapshot = void 0
                    }
                    resetTree() {
                        this.root.nodes.forEach(t => {
                            var e;
                            return null === (e = t.currentAnimation) || void 0 === e ? void 0 : e.stop()
                        }), this.root.nodes.forEach(r$), this.root.sharedNodes.clear()
                    }
                }
            }

            function rO(t) {
                t.updateLayout()
            }

            function rB(t) {
                var e;
                let i = (null === (e = t.resumeFrom) || void 0 === e ? void 0 : e.snapshot) || t.snapshot;
                if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
                    let {
                        layoutBox: e,
                        measuredBox: n
                    } = t.layout, {
                        animationType: r
                    } = t.options, s = i.source !== t.layout.source;
                    "size" === r ? n$(t => {
                        let n = s ? i.measuredBox[t] : i.layoutBox[t],
                            r = nC(n);
                        n.min = e[t].min, n.max = n.min + r
                    }) : r2(r, i.layoutBox, e) && n$(n => {
                        let r = s ? i.measuredBox[n] : i.layoutBox[n],
                            o = nC(e[n]);
                        r.max = r.min + o, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[n].max = t.relativeTarget[n].min + o)
                    });
                    let o = nI();
                    nk(o, e, i.layoutBox);
                    let a = nI();
                    s ? nk(a, t.applyTransform(n, !0), i.measuredBox) : nk(a, e, i.layoutBox);
                    let l = !rb(o),
                        u = !1;
                    if (!t.resumeFrom) {
                        let n = t.getClosestProjectingParent();
                        if (n && !n.resumeFrom) {
                            let {
                                snapshot: r,
                                layout: s
                            } = n;
                            if (r && s) {
                                let o = nN();
                                nD(o, i.layoutBox, r.layoutBox);
                                let a = nN();
                                nD(a, e, s.layoutBox), rS(o, a) || (u = !0), n.options.layoutRoot && (t.relativeTarget = a, t.relativeTargetOrigin = o, t.relativeParent = n)
                            }
                        }
                    }
                    t.notifyListeners("didUpdate", {
                        layout: e,
                        snapshot: i,
                        delta: a,
                        layoutDelta: o,
                        hasLayoutChanged: l,
                        hasRelativeTargetChanged: u
                    })
                } else if (t.isLead()) {
                    let {
                        onExitComplete: e
                    } = t.options;
                    e && e()
                }
                t.options.transition = void 0
            }

            function rI(t) {
                rM && rk.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
            }

            function rU(t) {
                t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
            }

            function rN(t) {
                t.clearSnapshot()
            }

            function r$(t) {
                t.clearMeasurements()
            }

            function rW(t) {
                t.isLayoutDirty = !1
            }

            function rz(t) {
                let {
                    visualElement: e
                } = t.options;
                e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform()
            }

            function rH(t) {
                t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0
            }

            function rZ(t) {
                t.resolveTargetDelta()
            }

            function rK(t) {
                t.calcProjection()
            }

            function rY(t) {
                t.resetSkewAndRotation()
            }

            function r_(t) {
                t.removeLeadSnapshot()
            }

            function rX(t, e, i) {
                t.translate = iB(e.translate, 0, i), t.scale = iB(e.scale, 1, i), t.origin = e.origin, t.originPoint = e.originPoint
            }

            function rq(t, e, i, n) {
                t.min = iB(e.min, i.min, n), t.max = iB(e.max, i.max, n)
            }

            function rG(t) {
                return t.animationValues && void 0 !== t.animationValues.opacityExit
            }
            let rJ = {
                    duration: .45,
                    ease: [.4, 0, .1, 1]
                },
                rQ = t => "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t),
                r0 = rQ("applewebkit/") && !rQ("chrome/") ? Math.round : tH.Z;

            function r1(t) {
                t.min = r0(t.min), t.max = r0(t.max)
            }

            function r2(t, e, i) {
                return "position" === t || "preserve-aspect" === t && !(.2 >= Math.abs(rT(e) - rT(i)))
            }

            function r5(t) {
                var e;
                return t !== t.root && (null === (e = t.scroll) || void 0 === e ? void 0 : e.wasRoot)
            }
            let r9 = rF({
                    attachResizeListener: (t, e) => tG(t, "resize", e),
                    measureScroll: () => ({
                        x: document.documentElement.scrollLeft || document.body.scrollLeft,
                        y: document.documentElement.scrollTop || document.body.scrollTop
                    }),
                    checkIsScrollRoot: () => !0
                }),
                r6 = {
                    current: void 0
                },
                r3 = rF({
                    measureScroll: t => ({
                        x: t.scrollLeft,
                        y: t.scrollTop
                    }),
                    defaultParent: () => {
                        if (!r6.current) {
                            let t = new r9({});
                            t.mount(window), t.setOptions({
                                layoutScroll: !0
                            }), r6.current = t
                        }
                        return r6.current
                    },
                    resetTransform: (t, e) => {
                        t.style.transform = void 0 !== e ? e : "none"
                    },
                    checkIsScrollRoot: t => "fixed" === window.getComputedStyle(t).position
                }),
                r8 = {
                    current: null
                },
                r4 = {
                    current: !1
                },
                r7 = new WeakMap,
                st = [...eU, e0, e4],
                se = t => st.find(eI(t)),
                si = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
                sn = E.length;
            class sr {
                scrapeMotionValuesFromProps(t, e, i) {
                    return {}
                }
                constructor({
                    parent: t,
                    props: e,
                    presenceContext: i,
                    reducedMotionConfig: n,
                    blockInitialAnimation: r,
                    visualState: s
                }, o = {}) {
                    this.applyWillChange = !1, this.resolveKeyframes = (t, e, i, n) => new this.KeyframeResolver(t, e, i, n, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = eK, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
                        this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                    }, this.isRenderScheduled = !1, this.scheduleRender = () => {
                        this.isRenderScheduled || (this.isRenderScheduled = !0, tZ.render(this.render, !1, !0))
                    };
                    let {
                        latestValues: a,
                        renderState: l
                    } = s;
                    this.latestValues = a, this.baseTarget = { ...a
                    }, this.initialValues = e.initial ? { ...a
                    } : {}, this.renderState = l, this.parent = t, this.props = e, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.blockInitialAnimation = !!r, this.isControllingVariants = C(e), this.isVariantNode = V(e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current);
                    let {
                        willChange: u,
                        ...h
                    } = this.scrapeMotionValuesFromProps(e, {}, this);
                    for (let t in h) {
                        let e = h[t];
                        void 0 !== a[t] && $(e) && e.set(a[t], !1)
                    }
                }
                mount(t) {
                    this.current = t, r7.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, e) => this.bindToMotionValue(e, t)), r4.current || function() {
                        if (r4.current = !0, D.j) {
                            if (window.matchMedia) {
                                let t = window.matchMedia("(prefers-reduced-motion)"),
                                    e = () => r8.current = t.matches;
                                t.addListener(e), e()
                            } else r8.current = !1
                        }
                    }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || r8.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
                }
                unmount() {
                    for (let t in r7.delete(this.current), this.projection && this.projection.unmount(), tK(this.notifyUpdate), tK(this.render), this.valueSubscriptions.forEach(t => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this), this.events) this.events[t].clear();
                    for (let t in this.features) {
                        let e = this.features[t];
                        e && (e.unmount(), e.isMounted = !1)
                    }
                    this.current = null
                }
                bindToMotionValue(t, e) {
                    let i = U.has(t),
                        n = e.on("change", e => {
                            this.latestValues[t] = e, this.props.onUpdate && tZ.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0)
                        }),
                        r = e.on("renderRequest", this.scheduleRender);
                    this.valueSubscriptions.set(t, () => {
                        n(), r(), e.owner && e.stop()
                    })
                }
                sortNodePosition(t) {
                    return this.current && this.sortInstanceNodePosition && this.type === t.type ? this.sortInstanceNodePosition(this.current, t.current) : 0
                }
                updateFeatures() {
                    let t = "animation";
                    for (t in R) {
                        let e = R[t];
                        if (!e) continue;
                        let {
                            isEnabled: i,
                            Feature: n
                        } = e;
                        if (!this.features[t] && n && i(this.props) && (this.features[t] = new n(this)), this.features[t]) {
                            let e = this.features[t];
                            e.isMounted ? e.update() : (e.mount(), e.isMounted = !0)
                        }
                    }
                }
                triggerBuild() {
                    this.build(this.renderState, this.latestValues, this.props)
                }
                measureViewportBox() {
                    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : nN()
                }
                getStaticValue(t) {
                    return this.latestValues[t]
                }
                setStaticValue(t, e) {
                    this.latestValues[t] = e
                }
                update(t, e) {
                    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;
                    for (let e = 0; e < si.length; e++) {
                        let i = si[e];
                        this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
                        let n = t["on" + i];
                        n && (this.propEventSubscriptions[i] = this.on(i, n))
                    }
                    this.prevMotionValues = function(t, e, i) {
                        for (let n in e) {
                            let r = e[n],
                                s = i[n];
                            if ($(r)) t.addValue(n, r);
                            else if ($(s)) t.addValue(n, na(r, {
                                owner: t
                            }));
                            else if (s !== r) {
                                if (t.hasValue(n)) {
                                    let e = t.getValue(n);
                                    !0 === e.liveStyle ? e.jump(r) : e.hasAnimated || e.set(r)
                                } else {
                                    let e = t.getStaticValue(n);
                                    t.addValue(n, na(void 0 !== e ? e : r, {
                                        owner: t
                                    }))
                                }
                            }
                        }
                        for (let n in i) void 0 === e[n] && t.removeValue(n);
                        return e
                    }(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
                }
                getProps() {
                    return this.props
                }
                getVariant(t) {
                    return this.props.variants ? this.props.variants[t] : void 0
                }
                getDefaultTransition() {
                    return this.props.transition
                }
                getTransformPagePoint() {
                    return this.props.transformPagePoint
                }
                getClosestVariantNode() {
                    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
                }
                getVariantContext(t = !1) {
                    if (t) return this.parent ? this.parent.getVariantContext() : void 0;
                    if (!this.isControllingVariants) {
                        let t = this.parent && this.parent.getVariantContext() || {};
                        return void 0 !== this.props.initial && (t.initial = this.props.initial), t
                    }
                    let e = {};
                    for (let t = 0; t < sn; t++) {
                        let i = E[t],
                            n = this.props[i];
                        (S(n) || !1 === n) && (e[i] = n)
                    }
                    return e
                }
                addVariantChild(t) {
                    let e = this.getClosestVariantNode();
                    if (e) return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t)
                }
                addValue(t, e) {
                    let i = this.values.get(t);
                    e !== i && (i && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get())
                }
                removeValue(t) {
                    this.values.delete(t);
                    let e = this.valueSubscriptions.get(t);
                    e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
                }
                hasValue(t) {
                    return this.values.has(t)
                }
                getValue(t, e) {
                    if (this.props.values && this.props.values[t]) return this.props.values[t];
                    let i = this.values.get(t);
                    return void 0 === i && void 0 !== e && (i = na(null === e ? void 0 : e, {
                        owner: this
                    }), this.addValue(t, i)), i
                }
                readValue(t, e) {
                    var i;
                    let n = void 0 === this.latestValues[t] && this.current ? null !== (i = this.getBaseTargetFromProps(this.props, t)) && void 0 !== i ? i : this.readValueFromInstance(this.current, t, this.options) : this.latestValues[t];
                    return null != n && ("string" == typeof n && (ek(n) || eC(n)) ? n = parseFloat(n) : !se(n) && e4.test(e) && (n = io(t, e)), this.setBaseTarget(t, $(n) ? n.get() : n)), $(n) ? n.get() : n
                }
                setBaseTarget(t, e) {
                    this.baseTarget[t] = e
                }
                getBaseTarget(t) {
                    var e;
                    let i;
                    let {
                        initial: n
                    } = this.props;
                    if ("string" == typeof n || "object" == typeof n) {
                        let r = tD(this.props, n, null === (e = this.presenceContext) || void 0 === e ? void 0 : e.custom);
                        r && (i = r[t])
                    }
                    if (n && void 0 !== i) return i;
                    let r = this.getBaseTargetFromProps(this.props, t);
                    return void 0 === r || $(r) ? void 0 !== this.initialValues[t] && void 0 === i ? void 0 : this.baseTarget[t] : r
                }
                on(t, e) {
                    return this.events[t] || (this.events[t] = new nn), this.events[t].add(e)
                }
                notify(t, ...e) {
                    this.events[t] && this.events[t].notify(...e)
                }
            }
            class ss extends sr {
                constructor() {
                    super(...arguments), this.KeyframeResolver = il
                }
                sortInstanceNodePosition(t, e) {
                    return 2 & t.compareDocumentPosition(e) ? 1 : -1
                }
                getBaseTargetFromProps(t, e) {
                    return t.style ? t.style[e] : void 0
                }
                removeValueFromRenderState(t, {
                    vars: e,
                    style: i
                }) {
                    delete e[t], delete i[t]
                }
            }
            class so extends ss {
                constructor() {
                    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = tE
                }
                readValueFromInstance(t, e) {
                    if (U.has(e)) {
                        let t = is(e);
                        return t && t.default || 0
                    } {
                        let i = window.getComputedStyle(t),
                            n = (th(e) ? i.getPropertyValue(e) : i[e]) || 0;
                        return "string" == typeof n ? n.trim() : n
                    }
                }
                measureInstanceViewportBox(t, {
                    transformPagePoint: e
                }) {
                    return nQ(t, e)
                }
                build(t, e, i) {
                    tf(t, e, i.transformTemplate)
                }
                scrapeMotionValuesFromProps(t, e, i) {
                    return tk(t, e, i)
                }
                handleChildMotionValue() {
                    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
                    let {
                        children: t
                    } = this.props;
                    $(t) && (this.childSubscription = t.on("change", t => {
                        this.current && (this.current.textContent = `${t}`)
                    }))
                }
            }
            class sa extends ss {
                constructor() {
                    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = nN
                }
                getBaseTargetFromProps(t, e) {
                    return t[e]
                }
                readValueFromInstance(t, e) {
                    if (U.has(e)) {
                        let t = is(e);
                        return t && t.default || 0
                    }
                    return e = tC.has(e) ? e : d(e), t.getAttribute(e)
                }
                scrapeMotionValuesFromProps(t, e, i) {
                    return tM(t, e, i)
                }
                build(t, e, i) {
                    tS(t, e, this.isSVGTag, i.transformTemplate)
                }
                renderInstance(t, e, i, n) {
                    tV(t, e, i, n)
                }
                mount(t) {
                    this.isSVGTag = tA(t.tagName), super.mount(t)
                }
            }
            let sl = (t, e) => O(t) ? new sa(e) : new so(e, {
                    allowProjection: t !== o.Fragment
                }),
                su = {
                    animation: {
                        Feature: ny
                    },
                    exit: {
                        Feature: nb
                    },
                    inView: {
                        Feature: ec
                    },
                    tap: {
                        Feature: es
                    },
                    focus: {
                        Feature: ei
                    },
                    hover: {
                        Feature: ee
                    },
                    pan: {
                        Feature: n3
                    },
                    drag: {
                        Feature: n9,
                        ProjectionNode: r3,
                        MeasureLayout: re
                    },
                    layout: {
                        ProjectionNode: r3,
                        MeasureLayout: re
                    }
                },
                sh = function(t) {
                    function e(e, i = {}) {
                        return function({
                            preloadedFeatures: t,
                            createVisualElement: e,
                            useRender: i,
                            useVisualState: n,
                            Component: r
                        }) {
                            t && function(t) {
                                for (let e in t) R[e] = { ...R[e],
                                    ...t[e]
                                }
                            }(t);
                            let d = (0, o.forwardRef)(function(t, d) {
                                var f;
                                let m;
                                let v = { ...(0, o.useContext)(a._),
                                        ...t,
                                        layoutId: function({
                                            layoutId: t
                                        }) {
                                            let e = (0, o.useContext)(j.p).id;
                                            return e && void 0 !== t ? e + "-" + t : t
                                        }(t)
                                    },
                                    {
                                        isStatic: y
                                    } = v,
                                    T = function(t) {
                                        let {
                                            initial: e,
                                            animate: i
                                        } = function(t, e) {
                                            if (C(t)) {
                                                let {
                                                    initial: e,
                                                    animate: i
                                                } = t;
                                                return {
                                                    initial: !1 === e || S(e) ? e : void 0,
                                                    animate: S(i) ? i : void 0
                                                }
                                            }
                                            return !1 !== t.inherit ? e : {}
                                        }(t, (0, o.useContext)(l));
                                        return (0, o.useMemo)(() => ({
                                            initial: e,
                                            animate: i
                                        }), [k(e), k(i)])
                                    }(t),
                                    A = n(t, y);
                                if (!y && D.j) {
                                    (0, o.useContext)(c).strict;
                                    let t = function(t) {
                                        let {
                                            drag: e,
                                            layout: i
                                        } = R;
                                        if (!e && !i) return {};
                                        let n = { ...e,
                                            ...i
                                        };
                                        return {
                                            MeasureLayout: (null == e ? void 0 : e.isEnabled(t)) || (null == i ? void 0 : i.isEnabled(t)) ? n.MeasureLayout : void 0,
                                            ProjectionNode: n.ProjectionNode
                                        }
                                    }(v);
                                    m = t.MeasureLayout, T.visualElement = function(t, e, i, n, r) {
                                        let {
                                            visualElement: s
                                        } = (0, o.useContext)(l), d = (0, o.useContext)(c), f = (0, o.useContext)(u.O), m = (0, o.useContext)(a._).reducedMotion, v = (0, o.useRef)();
                                        n = n || d.renderer, !v.current && n && (v.current = n(t, {
                                            visualState: e,
                                            parent: s,
                                            props: i,
                                            presenceContext: f,
                                            blockInitialAnimation: !!f && !1 === f.initial,
                                            reducedMotionConfig: m
                                        }));
                                        let y = v.current,
                                            S = (0, o.useContext)(b);
                                        y && !y.projection && r && ("html" === y.type || "svg" === y.type) && function(t, e, i, n) {
                                            let {
                                                layoutId: r,
                                                layout: s,
                                                drag: o,
                                                dragConstraints: a,
                                                layoutScroll: l,
                                                layoutRoot: u
                                            } = e;
                                            t.projection = new i(t.latestValues, e["data-framer-portal-id"] ? void 0 : function t(e) {
                                                if (e) return !1 !== e.options.allowProjection ? e.projection : t(e.parent)
                                            }(t.parent)), t.projection.setOptions({
                                                layoutId: r,
                                                layout: s,
                                                alwaysMeasureLayout: !!o || a && x(a),
                                                visualElement: t,
                                                animationType: "string" == typeof s ? s : "both",
                                                initialPromotionConfig: n,
                                                layoutScroll: l,
                                                layoutRoot: u
                                            })
                                        }(v.current, i, r, S), (0, o.useInsertionEffect)(() => {
                                            y && y.update(i, f)
                                        });
                                        let T = (0, o.useRef)(!!(i[p] && !window.HandoffComplete));
                                        return (0, h.L)(() => {
                                            y && (y.updateFeatures(), g.render(y.render), T.current && y.animationState && y.animationState.animateChanges())
                                        }), (0, o.useEffect)(() => {
                                            y && (!T.current && y.animationState && y.animationState.animateChanges(), T.current && (T.current = !1, w || (w = !0, queueMicrotask(P))))
                                        }), y
                                    }(r, A, v, e, t.ProjectionNode)
                                }
                                return (0, s.jsxs)(l.Provider, {
                                    value: T,
                                    children: [m && T.visualElement ? (0, s.jsx)(m, {
                                        visualElement: T.visualElement,
                                        ...v
                                    }) : null, i(r, t, (f = T.visualElement, (0, o.useCallback)(t => {
                                        t && A.mount && A.mount(t), f && (t ? f.mount(t) : f.unmount()), d && ("function" == typeof d ? d(t) : x(d) && (d.current = t))
                                    }, [f])), A, y, T.visualElement)]
                                })
                            });
                            return d[L] = r, d
                        }(t(e, i))
                    }
                    if ("undefined" == typeof Proxy) return e;
                    let i = new Map;
                    return new Proxy(e, {
                        get: (t, n) => (i.has(n) || i.set(n, e(n)), i.get(n))
                    })
                }((t, e) => (function(t, {
                    forwardMotionProps: e = !1
                }, i, n) {
                    return { ...O(t) ? tX : tq,
                        preloadedFeatures: i,
                        useRender: function(t = !1) {
                            return (e, i, n, {
                                latestValues: r
                            }, s) => {
                                let a = (O(e) ? function(t, e, i, n) {
                                        let r = (0, o.useMemo)(() => {
                                            let i = tT();
                                            return tS(i, e, tA(n), t.transformTemplate), { ...i.attrs,
                                                style: { ...i.style
                                                }
                                            }
                                        }, [e]);
                                        if (t.style) {
                                            let e = {};
                                            tv(e, t.style, t), r.style = { ...e,
                                                ...r.style
                                            }
                                        }
                                        return r
                                    } : function(t, e) {
                                        let i = {},
                                            n = function(t, e) {
                                                let i = t.style || {},
                                                    n = {};
                                                return tv(n, i, t), Object.assign(n, function({
                                                    transformTemplate: t
                                                }, e) {
                                                    return (0, o.useMemo)(() => {
                                                        let i = tm();
                                                        return tf(i, e, t), Object.assign({}, i.vars, i.style)
                                                    }, [e])
                                                }(t, e)), n
                                            }(t, e);
                                        return t.drag && !1 !== t.dragListener && (i.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = !0 === t.drag ? "none" : `pan-${"x"===t.drag?"y":"x"}`), void 0 === t.tabIndex && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = n, i
                                    })(i, r, s, e),
                                    l = function(t, e, i) {
                                        let n = {};
                                        for (let r in t)("values" !== r || "object" != typeof t.values) && (tx(r) || !0 === i && ty(r) || !e && !ty(r) || t.draggable && r.startsWith("onDrag")) && (n[r] = t[r]);
                                        return n
                                    }(i, "string" == typeof e, t),
                                    u = e !== o.Fragment ? { ...l,
                                        ...a,
                                        ref: n
                                    } : {},
                                    {
                                        children: h
                                    } = i,
                                    c = (0, o.useMemo)(() => $(h) ? h.get() : h, [h]);
                                return (0, o.createElement)(e, { ...u,
                                    children: c
                                })
                            }
                        }(e),
                        createVisualElement: n,
                        Component: t
                    }
                })(t, e, su, sl))
        },
        4188: function(t, e, i) {
            i.d(e, {
                K: function() {
                    return r
                },
                k: function() {
                    return s
                }
            });
            var n = i(7678);
            let r = n.Z,
                s = n.Z
        },
        7691: function(t, e, i) {
            i.d(e, {
                j: function() {
                    return n
                }
            });
            let n = "undefined" != typeof window
        },
        7678: function(t, e, i) {
            i.d(e, {
                Z: function() {
                    return n
                }
            });
            let n = t => t
        },
        8099: function(t, e, i) {
            i.d(e, {
                h: function() {
                    return r
                }
            });
            var n = i(6265);

            function r(t) {
                let e = (0, n.useRef)(null);
                return null === e.current && (e.current = t()), e.current
            }
        },
        3170: function(t, e, i) {
            i.d(e, {
                Y: function() {
                    return s
                }
            });
            var n = i(6265);
            i(4188);
            let r = {
                some: 0,
                all: 1
            };

            function s(t, {
                root: e,
                margin: i,
                amount: s,
                once: o = !1
            } = {}) {
                let [a, l] = (0, n.useState)(!1);
                return (0, n.useEffect)(() => {
                    if (!t.current || o && a) return;
                    let n = {
                        root: e && e.current || void 0,
                        margin: i,
                        amount: s
                    };
                    return function(t, e, {
                        root: i,
                        margin: n,
                        amount: s = "some"
                    } = {}) {
                        var o;
                        let a = ("string" == typeof(o = t) ? o = document.querySelectorAll(o) : o instanceof Element && (o = [o]), Array.from(o || [])),
                            l = new WeakMap,
                            u = new IntersectionObserver(t => {
                                t.forEach(t => {
                                    let i = l.get(t.target);
                                    if (!!i !== t.isIntersecting) {
                                        if (t.isIntersecting) {
                                            let i = e(t);
                                            "function" == typeof i ? l.set(t.target, i) : u.unobserve(t.target)
                                        } else i && (i(t), l.delete(t.target))
                                    }
                                })
                            }, {
                                root: i,
                                rootMargin: n,
                                threshold: "number" == typeof s ? s : r[s]
                            });
                        return a.forEach(t => u.observe(t)), () => u.disconnect()
                    }(t.current, () => (l(!0), o ? void 0 : () => l(!1)), n)
                }, [e, t, i, o, s]), a
            }
        },
        805: function(t, e, i) {
            i.d(e, {
                L: function() {
                    return r
                }
            });
            var n = i(6265);
            let r = i(7691).j ? n.useLayoutEffect : n.useEffect
        }
    }
]);